# Rules: 4033-4053

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | Zscaler |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | Zscaler |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | Zscaler |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | |
|DetectionType | Analytics |
|ConnectorId | MicrosoftSysmonForLinux |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | Syslog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | AzureMonitor(VMInsights) |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | VMConnection |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | AzureMonitor(VMInsights) |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | VMConnection |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## Excessive number of failed connections from a single source (ASIM Network Session schema)

'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1499|
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | AzureMonitor(VMInsights) |
|DetectionId | 4902eddb-34f7-44a8-ac94-8486366e9494 |
|DataTypes | VMConnection |
|QueryFrequency | 1h |
|QueryPeriod | 1h |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 5000;
_Im_NetworkSession(eventresult='Failure')
| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)
| where Count > threshold
| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | AWS|
|DetectionType | Analytics |
|ConnectorId | AWSS3 |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes |  |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | SaaS|
|DetectionType | Analytics |
|ConnectorId | AWSS3 |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes |  |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | |
|DetectionType | Analytics |
|ConnectorId | WindowsForwardedEvents |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | WindowsEvent |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | macOS|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | AWS|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure AD|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Office 365|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligence |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

# Rules: 4054-4074

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | macOS|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | AWS|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure AD|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Office 365|
|DetectionType | Analytics |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | DeviceNetworkEvents |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | DeviceNetworkEvents |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | SecurityEvents |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | SecurityEvent |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | Zscaler |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | Zscaler |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | Zscaler |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | |
|DetectionType | Analytics |
|ConnectorId | MicrosoftSysmonForLinux |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | Syslog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | PaloAltoNetworks |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Analytics |
|ConnectorId | PaloAltoNetworks |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## (Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)

'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Analytics |
|ConnectorId | PaloAltoNetworks |
|DetectionId | e2399891-383c-4caf-ae67-68a008b9f89e |
|DataTypes | CommonSecurityLog |
|QueryFrequency | 1h |
|QueryPeriod | 14d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let HAS_ANY_MAX = 10000;
let dt_lookBack = 1h;
let ioc_lookBack = 14d;
let IP_TI=ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId
| where Active == true
// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.
// Taking the first non-empty value based on potential IOC match availability
| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,"NO_IP")
// Picking up only IOC's that contain the entities we want
| where TI_ipEntity != "NO_IP";
let IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)
 | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));
IP_TI
  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
  | join kind=innerunique 
  (
      union 
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(SrcIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'
          ),
          (
          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)
          | where isnotempty(DstIpAddr)
          // renaming time column so it is clear the log this came from
          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'
          )
)on $left.TI_ipEntity == $right.IoCIP
| where imNWS_TimeGenerated < ExpirationDateTime
| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection
| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,
TI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP

```

## Potential beaconing activity (ASIM Network Session schema)

This rule identifies beaconing patterns from Network traffic logs based on recurrent frequency patterns. Such potential outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts as discussed in this [Blog](http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/).\<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | AWS|
|DetectionType | Analytics |
|ConnectorId | AWSS3 |
|DetectionId | fcb9d75c-c3c1-4910-8697-f136bfef2363 |
|DataTypes |  |
|QueryFrequency | 1d |
|QueryPeriod | 2d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/PossibleBeaconingActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let querystarttime = 2d;
let queryendtime = 1d;
let TimeDeltaThreshold = 10;
let TotalEventsThreshold = 15;
let PercentBeaconThreshold = 80;
_Im_NetworkSession(starttime=querystarttime, endtime=queryendtime)
| where not(ipv4_is_private(DstIpAddr))
| project TimeGenerated,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| sort by SrcIpAddr asc,TimeGenerated asc, DstIpAddr asc, DstPortNumber asc
| serialize
| extend nextTimeGenerated = next(TimeGenerated, 1), nextSrcIpAddr = next(SrcIpAddr, 1)
| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)
| where SrcIpAddr == nextSrcIpAddr
//Whitelisting criteria/ threshold criteria
| where TimeDeltainSeconds > TimeDeltaThreshold 
| project TimeGenerated, TimeDeltainSeconds,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| summarize count(), sum(DstBytes), sum(SrcBytes), make_list(TimeDeltainSeconds) 
by TimeDeltainSeconds, bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSrcBytes = sum(sum_SrcBytes), TotalDstBytes = sum(sum_DstBytes) 
by bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| where TotalEvents > TotalEventsThreshold 
| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100
| where BeaconPercent > PercentBeaconThreshold

```

## Potential beaconing activity (ASIM Network Session schema)

This rule identifies beaconing patterns from Network traffic logs based on recurrent frequency patterns. Such potential outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts as discussed in this [Blog](http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/).\<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | SaaS|
|DetectionType | Analytics |
|ConnectorId | AWSS3 |
|DetectionId | fcb9d75c-c3c1-4910-8697-f136bfef2363 |
|DataTypes |  |
|QueryFrequency | 1d |
|QueryPeriod | 2d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/PossibleBeaconingActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let querystarttime = 2d;
let queryendtime = 1d;
let TimeDeltaThreshold = 10;
let TotalEventsThreshold = 15;
let PercentBeaconThreshold = 80;
_Im_NetworkSession(starttime=querystarttime, endtime=queryendtime)
| where not(ipv4_is_private(DstIpAddr))
| project TimeGenerated,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| sort by SrcIpAddr asc,TimeGenerated asc, DstIpAddr asc, DstPortNumber asc
| serialize
| extend nextTimeGenerated = next(TimeGenerated, 1), nextSrcIpAddr = next(SrcIpAddr, 1)
| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)
| where SrcIpAddr == nextSrcIpAddr
//Whitelisting criteria/ threshold criteria
| where TimeDeltainSeconds > TimeDeltaThreshold 
| project TimeGenerated, TimeDeltainSeconds,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| summarize count(), sum(DstBytes), sum(SrcBytes), make_list(TimeDeltainSeconds) 
by TimeDeltainSeconds, bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSrcBytes = sum(sum_SrcBytes), TotalDstBytes = sum(sum_DstBytes) 
by bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| where TotalEvents > TotalEventsThreshold 
| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100
| where BeaconPercent > PercentBeaconThreshold

```

## Potential beaconing activity (ASIM Network Session schema)

This rule identifies beaconing patterns from Network traffic logs based on recurrent frequency patterns. Such potential outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts as discussed in this [Blog](http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/).\<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | |
|DetectionType | Analytics |
|ConnectorId | WindowsForwardedEvents |
|DetectionId | fcb9d75c-c3c1-4910-8697-f136bfef2363 |
|DataTypes | WindowsEvent |
|QueryFrequency | 1d |
|QueryPeriod | 2d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/PossibleBeaconingActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let querystarttime = 2d;
let queryendtime = 1d;
let TimeDeltaThreshold = 10;
let TotalEventsThreshold = 15;
let PercentBeaconThreshold = 80;
_Im_NetworkSession(starttime=querystarttime, endtime=queryendtime)
| where not(ipv4_is_private(DstIpAddr))
| project TimeGenerated,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| sort by SrcIpAddr asc,TimeGenerated asc, DstIpAddr asc, DstPortNumber asc
| serialize
| extend nextTimeGenerated = next(TimeGenerated, 1), nextSrcIpAddr = next(SrcIpAddr, 1)
| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)
| where SrcIpAddr == nextSrcIpAddr
//Whitelisting criteria/ threshold criteria
| where TimeDeltainSeconds > TimeDeltaThreshold 
| project TimeGenerated, TimeDeltainSeconds,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| summarize count(), sum(DstBytes), sum(SrcBytes), make_list(TimeDeltainSeconds) 
by TimeDeltainSeconds, bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSrcBytes = sum(sum_SrcBytes), TotalDstBytes = sum(sum_DstBytes) 
by bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| where TotalEvents > TotalEventsThreshold 
| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100
| where BeaconPercent > PercentBeaconThreshold

```

## Potential beaconing activity (ASIM Network Session schema)

This rule identifies beaconing patterns from Network traffic logs based on recurrent frequency patterns. Such potential outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts as discussed in this [Blog](http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/).\<br><br>
This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Azure|
|DetectionType | Analytics |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | fcb9d75c-c3c1-4910-8697-f136bfef2363 |
|DataTypes | DeviceNetworkEvents |
|QueryFrequency | 1d |
|QueryPeriod | 2d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/PossibleBeaconingActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let querystarttime = 2d;
let queryendtime = 1d;
let TimeDeltaThreshold = 10;
let TotalEventsThreshold = 15;
let PercentBeaconThreshold = 80;
_Im_NetworkSession(starttime=querystarttime, endtime=queryendtime)
| where not(ipv4_is_private(DstIpAddr))
| project TimeGenerated,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| sort by SrcIpAddr asc,TimeGenerated asc, DstIpAddr asc, DstPortNumber asc
| serialize
| extend nextTimeGenerated = next(TimeGenerated, 1), nextSrcIpAddr = next(SrcIpAddr, 1)
| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)
| where SrcIpAddr == nextSrcIpAddr
//Whitelisting criteria/ threshold criteria
| where TimeDeltainSeconds > TimeDeltaThreshold 
| project TimeGenerated, TimeDeltainSeconds,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes
| summarize count(), sum(DstBytes), sum(SrcBytes), make_list(TimeDeltainSeconds) 
by TimeDeltainSeconds, bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSrcBytes = sum(sum_SrcBytes), TotalDstBytes = sum(sum_DstBytes) 
by bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber
| where TotalEvents > TotalEventsThreshold 
| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100
| where BeaconPercent > PercentBeaconThreshold

```

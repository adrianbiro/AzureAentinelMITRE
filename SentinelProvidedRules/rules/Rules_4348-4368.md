# Rules: 4348-4368

## Potential IIS brute force

'This query shows when 1200 (20 per minute) or more failed attempts by cIP per hour occur on a given server and then a successful logon by cIP. 
This only includes when more than 1 user agent strings is used or more than 1 port is used.
This could be indicative of successful probing and password brute force success on your IIS servers. 
Feel free to adjust the threshold as needed - ConnectionCount >= 1200 
References: Status code mappings for your convenience, also inline if the mapping is not available
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(IIS) |
|DetectionId | 934011da-1fe6-4507-aadb-d3914c877bcd |
|DataTypes | W3CIISLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/Potential_IIS_BF.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

W3CIISLog
| where scStatus in ("401","403")
| where cIP !startswith "192.168." and cIP != sIP and cIP != "::1" //and csUserName != "-" 
// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI
| extend csUriQuery = iff(csUriQuery startswith "MailboxId=", tostring(split(csUriQuery, "&")[0]) , csUriQuery )
| extend csUriQuery = iff(csUriQuery startswith "X-ARR-CACHE-HIT=", strcat(tostring(split(csUriQuery, "&")[0]),tostring(split(csUriQuery, "&")[1])) , csUriQuery )
| summarize FailStartTime = min(TimeGenerated), FailEndTime = max(TimeGenerated), makeset(sPort), makeset(csUserAgent), makeset(csUserName), csUserNameCount = dcount(csUserName), ConnectionCount = count() by Computer, sSiteName, sIP, cIP, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)
| extend sPortCount = arraylength(set_sPort)
| extend scStatusFull = strcat(scStatus, ".",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == "401.0", "Access denied.",
scStatusFull == "401.1", "Logon failed.",
scStatusFull == "401.2", "Logon failed due to server configuration.",
scStatusFull == "401.3", "Unauthorized due to ACL on resource.",
scStatusFull == "401.4", "Authorization failed by filter.",
scStatusFull == "401.5", "Authorization failed by ISAPI/CGI application.",
scStatusFull == "403.0", "Forbidden.",
scStatusFull == "403.4", "SSL required.",
"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ "52e", "Logon failure: Unknown user name or bad password.", 
scWin32Status_Hex =~ "533", "Logon failure: Account currently disabled.", 
scWin32Status_Hex =~ "2ee2", "The request has timed out.", 
scWin32Status_Hex =~ "0", "The operation completed successfully.", 
scWin32Status_Hex =~ "1", "Incorrect function.", 
scWin32Status_Hex =~ "2", "The system cannot find the file specified.", 
scWin32Status_Hex =~ "3", "The system cannot find the path specified.", 
scWin32Status_Hex =~ "4", "The system cannot open the file.", 
scWin32Status_Hex =~ "5", "Access is denied.", 
scWin32Status_Hex =~ "8009030e", "SEC_E_NO_CREDENTIALS", 
scWin32Status_Hex =~ "8009030C", "SEC_E_LOGON_DENIED", 
"See - https://msdn.microsoft.com/library/cc231199.aspx")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
| where (ConnectionCount >= 1200 and csUserAgentPerIPCount > 1) or (ConnectionCount >= 1200 and sPortCount > 1)
// now join back to see if there is a successful logon after so many failures
| join (
W3CIISLog
| where scStatus startswith "20"
| where cIP !startswith "192.168." and cIP != sIP and cIP != "::1"
| extend LogonSuccessTime = TimeGenerated, Success_scStatus = scStatus
| distinct LogonSuccessTime, Computer, sSiteName, sIP, cIP, Success_scStatus
) on Computer, sSiteName, sIP, cIP
| where FailEndTime < LogonSuccessTime and not(LogonSuccessTime between (FailStartTime .. FailEndTime))
| summarize makeset(LogonSuccessTime) by FailStartTime, FailEndTime, Computer, sSiteName, sIP, cIP, tostring(set_csUserName), csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, tostring(set_sPort), tostring(set_csUserAgent), ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly
| project FailStartTime, FailEndTime, set_LogonSuccessTime, Computer, sSiteName, sIP, cIP, set_csUserName, csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, set_sPort, set_csUserAgent, ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly
| extend timestamp = FailStartTime, IPCustomEntity = cIP, HostCustomEntity = Computer

```

## Rare User Agent strings

'This will check for Rare User Agent strings over the last 3 days.  This can indicate potential probing of your IIS servers.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(IIS) |
|DetectionId | 3de523b5-9608-43d5-801e-732c741dd82e |
|DataTypes | W3CIISLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/RareUserAgentStrings.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

W3CIISLog
//Exclude local addresses, using ipv4_is_private operator
|where ipv4_is_private(cIP) == false and  cIP !startswith "fe80" and cIP !startswith "::" and cIP !startswith "127."  
| where isnotempty(csUserAgent) and csUserAgent !in~ ("-", "MSRPC")
| extend csUserAgent_size = string_size(csUserAgent)
| project TimeGenerated, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, 
scSubStatus, scWin32Status, csHost 
| join (
    W3CIISLog
	  // The below line can be used to exclude local IPs if these create noise
    |where ipv4_is_private(cIP) == false and  cIP !startswith "fe80" and cIP !startswith "::" and cIP !startswith "127."  
    | where isnotempty(csUserAgent) and csUserAgent !in~ ("-", "MSRPC") 
    | extend csUserAgent_size = string_size(csUserAgent)
    | summarize csUserAgent_count = count() by bin(csUserAgent_size, 1)
    | top 20 by csUserAgent_count asc nulls last 
) on csUserAgent_size
| project TimeGenerated, sSiteName, sPort, sIP, cIP, csUserAgent, csUserAgent_size, csUserAgent_count, csUserName , csMethod, csUriStem, 
scStatus, scSubStatus, scWin32Status, csHost
| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName 

```

## Web Shell Activity

'Web shells are scripts that, when uploaded to a web server, can be used to provide a backdoor to a compromised network.
Attackers can use this entry point to leave malicious implants, such as obtaining unauthorized access, escalating privilege, and further compromising the environment.

This query hunts for web shells by analysing the distribution of commonly-used web shell scripts against regular scripts for those public client IPs which have not observed any W3CIIS activity in a fixed lookback period.
The results obtained summarise the public client IPs, user agents, and the distribution of the above scripts between the start and end time.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1505|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(IIS) |
|DetectionId | e0c947c3-fe83-46ff-bbda-a43224a785fd |
|DataTypes | W3CIISLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/WebShellActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - (3d);
let script_extensions = dynamic([".asp", ".aspx", ".armx", ".asax", ".ashz", ".asmx", ".axd", ".cshtml", ".php", ".phps", ".php3", ".php4", ".php5", ".php7", ".jsp", ".jspx", ".cfm", ".cfml", ".phtml"]);
let ignore_uristems = dynamic(["/ews/exchange.asmx"]);
let lookback_period = (
W3CIISLog
| where TimeGenerated between (lookback .. starttime)
//Exclude local addresses, using the ipv4_is_private operator
| where ipv4_is_private(cIP) == false and  cIP !startswith "fe80" and cIP !startswith "::" and cIP !startswith "127."
| summarize count() by cIP, csUserAgent
| project cIP, csUserAgent
);
let potential_webshell_activity = (W3CIISLog
| where TimeGenerated between (starttime .. endtime)
| extend csUriStem = tolower(csUriStem)
| where csUriStem matches regex "\\.[a-zA-Z][a-zA-Z0-9]+$"
| where csUriStem !in~ (ignore_uristems) // Remove noisy uri stems in the final results by editing the ignore_uristems variable
| extend suffix = strcat(".", split(split(csUriStem, "/")[-1], ".")[-1])
| extend is_script = iff(suffix in (script_extensions), 1, 0)
//Exclude local addresses using ipv4_is_private operator
|where ipv4_is_private(cIP) == false and  cIP !startswith "fe80" and cIP !startswith "::" and cIP !startswith "127."
| extend status_xx = strcat(substring(tostring(scStatus), 0, 1), 'XX')
| serialize cIP, csUserAgent, TimeGenerated
| extend SessionStarted = row_window_session(TimeGenerated, 30s, 3s, (cIP != prev(cIP)) and (csUserAgent != prev(csUserAgent))));
let dynamic_scripts = (potential_webshell_activity
| where is_script == 1
| summarize set_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);
let non_dynamic_scripts = (potential_webshell_activity
| where is_script == 0
| summarize set_non_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);
potential_webshell_activity
| summarize num_non_dyn_scripts = count() - sum(is_script), num_dynamic_scripts = sum(is_script) by cIP, csUserAgent, SessionStarted
| join kind=leftanti (lookback_period) on cIP, csUserAgent
| join kind=inner (dynamic_scripts) on cIP, csUserAgent, SessionStarted
| join kind=leftouter (non_dynamic_scripts) on cIP, csUserAgent, SessionStarted
| extend dyn_to_non_dyn_ratio = iff(num_non_dyn_scripts == 0, 10000.0, 1.0 * num_dynamic_scripts/num_non_dyn_scripts)
| project cIP, csUserAgent, SessionStarted,  num_dynamic_scripts, set_dynamic_scripts, num_non_dyn_scripts, set_non_dynamic_scripts,  dyn_to_non_dyn_ratio
| sort by dyn_to_non_dyn_ratio desc, num_dynamic_scripts desc
| extend summary = pack('IPCustomEntity', cIP, 'user_agent', csUserAgent, 'num_dynamic_scripts', num_dynamic_scripts, 'set_dynamic_scripts', set_dynamic_scripts, 'num_non_dyn_scripts', num_non_dyn_scripts, 'set_non_dynamic_scripts', set_non_dynamic_scripts, 'ratio', dyn_to_non_dyn_ratio, 'Session_StartTime', SessionStarted)
| summarize summaries=make_list(summary), num_of_sessions_on_day = count() by cIP, csUserAgent
| sort by num_of_sessions_on_day asc

```

## Web Shell Activity

'Web shells are scripts that, when uploaded to a web server, can be used to provide a backdoor to a compromised network.
Attackers can use this entry point to leave malicious implants, such as obtaining unauthorized access, escalating privilege, and further compromising the environment.

This query hunts for web shells by analysing the distribution of commonly-used web shell scripts against regular scripts for those public client IPs which have not observed any W3CIIS activity in a fixed lookback period.
The results obtained summarise the public client IPs, user agents, and the distribution of the above scripts between the start and end time.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1505|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(IIS) |
|DetectionId | e0c947c3-fe83-46ff-bbda-a43224a785fd |
|DataTypes | W3CIISLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/WebShellActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - (3d);
let script_extensions = dynamic([".asp", ".aspx", ".armx", ".asax", ".ashz", ".asmx", ".axd", ".cshtml", ".php", ".phps", ".php3", ".php4", ".php5", ".php7", ".jsp", ".jspx", ".cfm", ".cfml", ".phtml"]);
let ignore_uristems = dynamic(["/ews/exchange.asmx"]);
let lookback_period = (
W3CIISLog
| where TimeGenerated between (lookback .. starttime)
//Exclude local addresses, using the ipv4_is_private operator
| where ipv4_is_private(cIP) == false and  cIP !startswith "fe80" and cIP !startswith "::" and cIP !startswith "127."
| summarize count() by cIP, csUserAgent
| project cIP, csUserAgent
);
let potential_webshell_activity = (W3CIISLog
| where TimeGenerated between (starttime .. endtime)
| extend csUriStem = tolower(csUriStem)
| where csUriStem matches regex "\\.[a-zA-Z][a-zA-Z0-9]+$"
| where csUriStem !in~ (ignore_uristems) // Remove noisy uri stems in the final results by editing the ignore_uristems variable
| extend suffix = strcat(".", split(split(csUriStem, "/")[-1], ".")[-1])
| extend is_script = iff(suffix in (script_extensions), 1, 0)
//Exclude local addresses using ipv4_is_private operator
|where ipv4_is_private(cIP) == false and  cIP !startswith "fe80" and cIP !startswith "::" and cIP !startswith "127."
| extend status_xx = strcat(substring(tostring(scStatus), 0, 1), 'XX')
| serialize cIP, csUserAgent, TimeGenerated
| extend SessionStarted = row_window_session(TimeGenerated, 30s, 3s, (cIP != prev(cIP)) and (csUserAgent != prev(csUserAgent))));
let dynamic_scripts = (potential_webshell_activity
| where is_script == 1
| summarize set_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);
let non_dynamic_scripts = (potential_webshell_activity
| where is_script == 0
| summarize set_non_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);
potential_webshell_activity
| summarize num_non_dyn_scripts = count() - sum(is_script), num_dynamic_scripts = sum(is_script) by cIP, csUserAgent, SessionStarted
| join kind=leftanti (lookback_period) on cIP, csUserAgent
| join kind=inner (dynamic_scripts) on cIP, csUserAgent, SessionStarted
| join kind=leftouter (non_dynamic_scripts) on cIP, csUserAgent, SessionStarted
| extend dyn_to_non_dyn_ratio = iff(num_non_dyn_scripts == 0, 10000.0, 1.0 * num_dynamic_scripts/num_non_dyn_scripts)
| project cIP, csUserAgent, SessionStarted,  num_dynamic_scripts, set_dynamic_scripts, num_non_dyn_scripts, set_non_dynamic_scripts,  dyn_to_non_dyn_ratio
| sort by dyn_to_non_dyn_ratio desc, num_dynamic_scripts desc
| extend summary = pack('IPCustomEntity', cIP, 'user_agent', csUserAgent, 'num_dynamic_scripts', num_dynamic_scripts, 'set_dynamic_scripts', set_dynamic_scripts, 'num_non_dyn_scripts', num_non_dyn_scripts, 'set_non_dynamic_scripts', set_non_dynamic_scripts, 'ratio', dyn_to_non_dyn_ratio, 'Session_StartTime', SessionStarted)
| summarize summaries=make_list(summary), num_of_sessions_on_day = count() by cIP, csUserAgent
| sort by num_of_sessions_on_day asc

```

## Web shell Detection

'Web shells are script that when uploaded to a web server can be used for remote administration. 
Attackers often use web shells to obtain unauthorized access, escalate //privilege as well as further compromise the environment. 
The query detects web shells that use GET requests by keyword searches in URL strings. 
This is based out of sigma rules described //here (https://github.com/Neo23x0/sigma/blob/master/rules/web/web_webshell_keyword.yml). 
There could be some web sites like wikis with articles on os commands and pages that include the os //commands in the URLs that might cause FP.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1505|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(IIS) |
|DetectionId | cc087e7c-4db0-4bf9-9e48-287a9c9c3fbc |
|DataTypes | W3CIISLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/PotentialWebshell.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let command = "(?i)net(1)?(.exe)?(%20){1,}user|cmd(.exe)?(%20){1,}/c(%20){1,}";
W3CIISLog
| where csMethod == "GET" 
| where ( csUriQuery has "whoami" or csUriQuery matches regex command ) or 
        ( csUriStem has "whoami" or csUriStem matches regex command ) or
        ( csReferer has "whoami" or csReferer matches regex command )
| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), ConnectionCount = count() 
by Computer, sSiteName, sIP, cIP, csUserName, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName 

```

## Web shell Detection

'Web shells are script that when uploaded to a web server can be used for remote administration. 
Attackers often use web shells to obtain unauthorized access, escalate //privilege as well as further compromise the environment. 
The query detects web shells that use GET requests by keyword searches in URL strings. 
This is based out of sigma rules described //here (https://github.com/Neo23x0/sigma/blob/master/rules/web/web_webshell_keyword.yml). 
There could be some web sites like wikis with articles on os commands and pages that include the os //commands in the URLs that might cause FP.'

|Name | Value |
| --- | --- |
|Tactic | PrivilegeEscalation|
|TechniqueId | T1505|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(IIS) |
|DetectionId | cc087e7c-4db0-4bf9-9e48-287a9c9c3fbc |
|DataTypes | W3CIISLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/PotentialWebshell.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let command = "(?i)net(1)?(.exe)?(%20){1,}user|cmd(.exe)?(%20){1,}/c(%20){1,}";
W3CIISLog
| where csMethod == "GET" 
| where ( csUriQuery has "whoami" or csUriQuery matches regex command ) or 
        ( csUriStem has "whoami" or csUriStem matches regex command ) or
        ( csReferer has "whoami" or csReferer matches regex command )
| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), ConnectionCount = count() 
by Computer, sSiteName, sIP, cIP, csUserName, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName 

```

## Possible SpringShell Exploitation Attempt (CVE-2022-22965)

'This hunting query looks in Azure Web Application Firewall data to find possible SpringShell Exploitation Attempt (CVE-2022-22965).
 The Spring Framework is one of the most widely used lightweight open-source framework for Java. To exploit the vulnerability attackers can  
 send a specially crafted query to a web server running the Spring Core framework to change the target of logging facility and create a new 
 malicious JSP file in a location accessible by http requests. Attackers then make requests to the malicious backdoor to run system commands.
 Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 1bb4a007-7d1d-4506-ada9-222604f54ec6 |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/SpringShellExploitationAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let spring4shellstring = dynamic(["class.module.classLoader.resources.context.parent.pipeline.first.pattern="]);
AzureDiagnostics
| where Category in ("FrontdoorWebApplicationFirewallLog", "FrontdoorAccessLog", "ApplicationGatewayFirewallLog", "ApplicationGatewayAccessLog")
| extend originalRequestUriWithArgs_s = column_ifexists("originalRequestUriWithArgs_s", ""), 
   userAgent_s = column_ifexists("userAgent_s", ""), 
   clientIP_s = column_ifexists("clientIP_s", ""),  
   clientPort_d = column_ifexists("originalRequestUriWithArgs_s", ""),
   host_s = column_ifexists("host_s", ""),
   requestUri_s = column_ifexists("requestUri_s", ""),
   httpStatus_d = column_ifexists("httpStatus_d",""),
   listenerName_s = column_ifexists("listenerName_s", ""),
   httpMethod_s = column_ifexists("httpMethod_s", "")
| where httpMethod_s =~ 'POST'
| where originalRequestUriWithArgs_s has_any (spring4shellstring) or requestUri_s has_any (spring4shellstring)
| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, httpMethod_s, Category
| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated, UrlCustomEntity = requestUri_s, HostCustomEntity = host_s

```

## Possible SpringShell Exploitation Attempt (CVE-2022-22965)

'This hunting query looks in Azure Web Application Firewall data to find possible SpringShell Exploitation Attempt (CVE-2022-22965).
 The Spring Framework is one of the most widely used lightweight open-source framework for Java. To exploit the vulnerability attackers can  
 send a specially crafted query to a web server running the Spring Core framework to change the target of logging facility and create a new 
 malicious JSP file in a location accessible by http requests. Attackers then make requests to the malicious backdoor to run system commands.
 Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 1bb4a007-7d1d-4506-ada9-222604f54ec6 |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/SpringShellExploitationAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let spring4shellstring = dynamic(["class.module.classLoader.resources.context.parent.pipeline.first.pattern="]);
AzureDiagnostics
| where Category in ("FrontdoorWebApplicationFirewallLog", "FrontdoorAccessLog", "ApplicationGatewayFirewallLog", "ApplicationGatewayAccessLog")
| extend originalRequestUriWithArgs_s = column_ifexists("originalRequestUriWithArgs_s", ""), 
   userAgent_s = column_ifexists("userAgent_s", ""), 
   clientIP_s = column_ifexists("clientIP_s", ""),  
   clientPort_d = column_ifexists("originalRequestUriWithArgs_s", ""),
   host_s = column_ifexists("host_s", ""),
   requestUri_s = column_ifexists("requestUri_s", ""),
   httpStatus_d = column_ifexists("httpStatus_d",""),
   listenerName_s = column_ifexists("listenerName_s", ""),
   httpMethod_s = column_ifexists("httpMethod_s", "")
| where httpMethod_s =~ 'POST'
| where originalRequestUriWithArgs_s has_any (spring4shellstring) or requestUri_s has_any (spring4shellstring)
| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, httpMethod_s, Category
| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated, UrlCustomEntity = requestUri_s, HostCustomEntity = host_s

```

## Possible Webshell usage attempt related to SpringShell(CVE-2022-22965)

'This hunting query looks in Azure Web Application Firewall data to find possible Webshell usage attempts related to SpringShell RCE vulnerability (CVE-2022-22965).
 The Spring Framework is one of the most widely used lightweight open-source framework for Java. The vulnerability in Spring Core can be exploited when an attacker 
 sends a specially crafted query to a web server running the Spring Core framework to create a backdoor shell.
 Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'

|Name | Value |
| --- | --- |
|Tactic | Execution|
|TechniqueId | T1059.007|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 6911d1df-4204-43b2-a64c-3cb102551ddd |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/SpringshellWebshellUsage.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let spring4shellstring = dynamic([".jsp?pwd=", ".jsp?cmd="]);
AzureDiagnostics
| where Category in ("FrontdoorWebApplicationFirewallLog", "FrontdoorAccessLog", "ApplicationGatewayFirewallLog", "ApplicationGatewayAccessLog")
| extend originalRequestUriWithArgs_s = column_ifexists("originalRequestUriWithArgs_s", ""), 
   userAgent_s = column_ifexists("userAgent_s", ""), 
   clientIP_s = column_ifexists("clientIP_s", ""),  
   clientPort_d = column_ifexists("originalRequestUriWithArgs_s", ""),
   host_s = column_ifexists("host_s", ""),
   requestUri_s = column_ifexists("requestUri_s", ""),
   httpStatus_d = column_ifexists("httpStatus_d",""),
   listenerName_s = column_ifexists("listenerName_s", ""),
   httpMethod_s = column_ifexists("httpMethod_s", "")
| where httpMethod_s =~ 'GET'
| where originalRequestUriWithArgs_s has_any (spring4shellstring) or requestUri_s has_any (spring4shellstring)
| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, httpMethod_s, Category
| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated, UrlCustomEntity = requestUri_s, HostCustomEntity = host_s

```

## Possible Webshell usage attempt related to SpringShell(CVE-2022-22965)

'This hunting query looks in Azure Web Application Firewall data to find possible Webshell usage attempts related to SpringShell RCE vulnerability (CVE-2022-22965).
 The Spring Framework is one of the most widely used lightweight open-source framework for Java. The vulnerability in Spring Core can be exploited when an attacker 
 sends a specially crafted query to a web server running the Spring Core framework to create a backdoor shell.
 Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'

|Name | Value |
| --- | --- |
|Tactic | Execution|
|TechniqueId | T1059.007|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 6911d1df-4204-43b2-a64c-3cb102551ddd |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/SpringshellWebshellUsage.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let spring4shellstring = dynamic([".jsp?pwd=", ".jsp?cmd="]);
AzureDiagnostics
| where Category in ("FrontdoorWebApplicationFirewallLog", "FrontdoorAccessLog", "ApplicationGatewayFirewallLog", "ApplicationGatewayAccessLog")
| extend originalRequestUriWithArgs_s = column_ifexists("originalRequestUriWithArgs_s", ""), 
   userAgent_s = column_ifexists("userAgent_s", ""), 
   clientIP_s = column_ifexists("clientIP_s", ""),  
   clientPort_d = column_ifexists("originalRequestUriWithArgs_s", ""),
   host_s = column_ifexists("host_s", ""),
   requestUri_s = column_ifexists("requestUri_s", ""),
   httpStatus_d = column_ifexists("httpStatus_d",""),
   listenerName_s = column_ifexists("listenerName_s", ""),
   httpMethod_s = column_ifexists("httpMethod_s", "")
| where httpMethod_s =~ 'GET'
| where originalRequestUriWithArgs_s has_any (spring4shellstring) or requestUri_s has_any (spring4shellstring)
| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, httpMethod_s, Category
| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated, UrlCustomEntity = requestUri_s, HostCustomEntity = host_s

```

## Azure Key Vault Access Policy Manipulation

'Identifies when a user is added and then removed to an Azure Key Vault access policy within a short time period. 
This may be a sign of credential access and persistence.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1555|
|Platform | |
|DetectionType | Hunting |
|ConnectorId | AzureKeyVault |
|DetectionId | 8eff7055-9138-4edc-b8f0-48ea27e23c3c |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/AzureKeyVaultAccessManipulation.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureDiagnostics
| where ResourceType == "VAULTS"
| where OperationName == "VaultPatch"
| where ResultType == "Success"
| extend UserObjectAdded = addedAccessPolicy_ObjectId_g
| extend AddedActor = identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_name_s
| extend KeyAccessAdded = tostring(addedAccessPolicy_Permissions_keys_s)
| extend SecretAccessAdded = tostring(addedAccessPolicy_Permissions_secrets_s)
| extend CertAccessAdded = tostring(addedAccessPolicy_Permissions_certificates_s)
| where isnotempty(UserObjectAdded)
| project AccessAddedTime=TimeGenerated, ResourceType, OperationName, ResultType, KeyVaultName=id_s, AddedActor, UserObjectAdded, KeyAccessAdded, SecretAccessAdded, CertAccessAdded
| join kind=inner 
( 
AzureDiagnostics
| where ResourceType == "VAULTS"
| where OperationName == "VaultPatch"
| where ResultType == "Success"
| extend RemovedActor = identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_name_s
| extend UserObjectRemoved = removedAccessPolicy_ObjectId_g
| extend KeyAccessRemoved = tostring(removedAccessPolicy_Permissions_keys_s)
| extend SecretAccessRemoved = tostring(removedAccessPolicy_Permissions_secrets_s)
| extend CertAccessRemoved = tostring(removedAccessPolicy_Permissions_certificates_s)
| where isnotempty(UserObjectRemoved)
| project AccessRemovedTime=TimeGenerated, ResourceType, OperationName, ResultType, KeyVaultName=id_s, RemovedActor, UserObjectRemoved, KeyAccessRemoved, SecretAccessRemoved, CertAccessRemoved
)
on KeyVaultName
| extend TimeDelta = abs(AccessAddedTime - AccessRemovedTime)
| where TimeDelta < timeframe
| project KeyVaultName, AccessAddedTime, AddedActor, UserObjectAdded, KeyAccessAdded, SecretAccessAdded, CertAccessAdded, AccessRemovedTime, RemovedActor, UserObjectRemoved, KeyAccessRemoved, SecretAccessRemoved, CertAccessRemoved, TimeDelta
| extend timestamp = AccessAddedTime, AccountCustomEntity = UserObjectAdded

```

## Azure WAF Log4j CVE-2021-44228 hunting

'This hunting query looks in Azure Web Application Firewall data to find possible exploitation attempts for CVE-2021-44228 involving log4j vulnerability.
 Refrence: https://www.microsoft.com/security/blog/2021/12/11/guidance-for-preventing-detecting-and-hunting-for-cve-2021-44228-log4j-2-exploitation/'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 1d4d383e-0ca6-4d3a-a861-8f37aeef18cb |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/WAF_log4j_vulnerability.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let log4jcmdstring = dynamic(["${jndi:ldap","${jndi:dns","${jndi:rmi","${jndi:corba","${jndi:iiop","${jndi:nis","${jndi:nds"]);
let log4jRegex = @'(\\$|%24)(\\{|%7B)([^jJ]*[jJ])([^nN]*[nN])([^dD]*[dD])([^iI]*[iI])(:|%3A|\\$|%24|}|%7D)';
AzureDiagnostics
| where Category in ("FrontdoorWebApplicationFirewallLog", "FrontdoorAccessLog", "ApplicationGatewayFirewallLog", "ApplicationGatewayAccessLog")
 //Extending the columns to aviod failures.
| extend originalRequestUriWithArgs_s = column_ifexists("originalRequestUriWithArgs_s", ""), 
  userAgent_s = column_ifexists("userAgent_s", ""), 
  clientIP_s = column_ifexists("clientIP_s", ""),  
  clientPort_d = column_ifexists("originalRequestUriWithArgs_s", ""),
  host_s = column_ifexists("host_s", ""),
  requestUri_s = column_ifexists("requestUri_s", ""),
  httpStatus_d = column_ifexists("httpStatus_d",""),
  listenerName_s = column_ifexists("listenerName_s", ""),
  httpMethod_s = column_ifexists("httpMethod_s", "")
 //The regex and the string matching look for the most common attacks. This is not supposed to be comprehensive.
| where originalRequestUriWithArgs_s has_any (log4jcmdstring) or originalRequestUriWithArgs_s matches regex log4jRegex or userAgent_s has_any (log4jcmdstring) or  userAgent_s matches regex log4jRegex
| extend CmdLine = iff(originalRequestUriWithArgs_s has 'Base64/', split(split(originalRequestUriWithArgs_s, "Base64/",1)[0], "}", 0)[0], split(split(userAgent_s, "Base64/",1)[0], "}", 0)[0])
| extend CmdLine = base64_decode_tostring(tostring(CmdLine))
| where CmdLine has_any ("wget","curl")
| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, CmdLine, httpMethod_s, Category
| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated

```

## Azure WAF Log4j CVE-2021-44228 hunting

'This hunting query looks in Azure Web Application Firewall data to find possible exploitation attempts for CVE-2021-44228 involving log4j vulnerability.
 Refrence: https://www.microsoft.com/security/blog/2021/12/11/guidance-for-preventing-detecting-and-hunting-for-cve-2021-44228-log4j-2-exploitation/'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 1d4d383e-0ca6-4d3a-a861-8f37aeef18cb |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/WAF_log4j_vulnerability.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let log4jcmdstring = dynamic(["${jndi:ldap","${jndi:dns","${jndi:rmi","${jndi:corba","${jndi:iiop","${jndi:nis","${jndi:nds"]);
let log4jRegex = @'(\\$|%24)(\\{|%7B)([^jJ]*[jJ])([^nN]*[nN])([^dD]*[dD])([^iI]*[iI])(:|%3A|\\$|%24|}|%7D)';
AzureDiagnostics
| where Category in ("FrontdoorWebApplicationFirewallLog", "FrontdoorAccessLog", "ApplicationGatewayFirewallLog", "ApplicationGatewayAccessLog")
 //Extending the columns to aviod failures.
| extend originalRequestUriWithArgs_s = column_ifexists("originalRequestUriWithArgs_s", ""), 
  userAgent_s = column_ifexists("userAgent_s", ""), 
  clientIP_s = column_ifexists("clientIP_s", ""),  
  clientPort_d = column_ifexists("originalRequestUriWithArgs_s", ""),
  host_s = column_ifexists("host_s", ""),
  requestUri_s = column_ifexists("requestUri_s", ""),
  httpStatus_d = column_ifexists("httpStatus_d",""),
  listenerName_s = column_ifexists("listenerName_s", ""),
  httpMethod_s = column_ifexists("httpMethod_s", "")
 //The regex and the string matching look for the most common attacks. This is not supposed to be comprehensive.
| where originalRequestUriWithArgs_s has_any (log4jcmdstring) or originalRequestUriWithArgs_s matches regex log4jRegex or userAgent_s has_any (log4jcmdstring) or  userAgent_s matches regex log4jRegex
| extend CmdLine = iff(originalRequestUriWithArgs_s has 'Base64/', split(split(originalRequestUriWithArgs_s, "Base64/",1)[0], "}", 0)[0], split(split(userAgent_s, "Base64/",1)[0], "}", 0)[0])
| extend CmdLine = base64_decode_tostring(tostring(CmdLine))
| where CmdLine has_any ("wget","curl")
| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, CmdLine, httpMethod_s, Category
| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated

```

## Check critical ports opened to the entire internet

'Discover all critical ports from a list having rules like 'Any' for sourceIp, which means that they are opened to everyone. Critial ports should not be opened to everyone, and should be filtered.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 66d494c0-233c-438a-9b1b-5fe839790d38 |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/CriticalPortsOpened.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

//Check critical ports opened to the entire internet
AzureDiagnostics
| where Category == "NetworkSecurityGroupEvent" 
| where direction_s == "In" 
| where conditions_destinationPortRange_s in (
"22","22-22"          //SSH
,"3389","3389-3389"   //RDP
,"137","137-137"      //NetBIOS
,"138","138-138"      //NetBIOS
,"139","139-139"      //SMB
,"53","53-53"         //DNS
,"3020","3020-3020"   //CIFS
,"3306","3306-3306"   //MySQL
,"1521","1521-1521"   //Oracle Database
,"2483","2483-2483"   //Oracle Database
,"5432","5432-5432"   //PostgreSQL
,"389","389-389"      //LDAP
,"27017","27017-27017"//MongoDB
,"20","20-20"         //FTP
,"21","21-21"         //FTP
,"445","445-445"      //Active Directory
,"161","161-161"      //SNMP
,"25","25-25"         //SMTP
)
 or (conditions_destinationPortRange_s == "0-65535" and conditions_sourcePortRange_s == "0-65535")
| where priority_d < 65000    //Not to check the Azure defaults
| where conditions_sourceIP_s == "0.0.0.0/0,0.0.0.0/0" or conditions_sourceIP_s == "0.0.0.0/0" //With rules Any/Any
| where type_s !~ "block"
| order by TimeGenerated desc
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by OperationName, systemId_g, vnetResourceGuid_g, subnetPrefix_s, macAddress_s, primaryIPv4Address_s, ruleName_s, direction_s, priority_d, type_s, conditions_destinationIP_s, conditions_destinationPortRange_s, conditions_sourceIP_s, conditions_sourcePortRange_s, ResourceId
| extend timestamp = StartTime

```

## Check critical ports opened to the entire internet

'Discover all critical ports from a list having rules like 'Any' for sourceIp, which means that they are opened to everyone. Critial ports should not be opened to everyone, and should be filtered.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | |
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | WAF |
|DetectionId | 66d494c0-233c-438a-9b1b-5fe839790d38 |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/CriticalPortsOpened.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

//Check critical ports opened to the entire internet
AzureDiagnostics
| where Category == "NetworkSecurityGroupEvent" 
| where direction_s == "In" 
| where conditions_destinationPortRange_s in (
"22","22-22"          //SSH
,"3389","3389-3389"   //RDP
,"137","137-137"      //NetBIOS
,"138","138-138"      //NetBIOS
,"139","139-139"      //SMB
,"53","53-53"         //DNS
,"3020","3020-3020"   //CIFS
,"3306","3306-3306"   //MySQL
,"1521","1521-1521"   //Oracle Database
,"2483","2483-2483"   //Oracle Database
,"5432","5432-5432"   //PostgreSQL
,"389","389-389"      //LDAP
,"27017","27017-27017"//MongoDB
,"20","20-20"         //FTP
,"21","21-21"         //FTP
,"445","445-445"      //Active Directory
,"161","161-161"      //SNMP
,"25","25-25"         //SMTP
)
 or (conditions_destinationPortRange_s == "0-65535" and conditions_sourcePortRange_s == "0-65535")
| where priority_d < 65000    //Not to check the Azure defaults
| where conditions_sourceIP_s == "0.0.0.0/0,0.0.0.0/0" or conditions_sourceIP_s == "0.0.0.0/0" //With rules Any/Any
| where type_s !~ "block"
| order by TimeGenerated desc
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by OperationName, systemId_g, vnetResourceGuid_g, subnetPrefix_s, macAddress_s, primaryIPv4Address_s, ruleName_s, direction_s, priority_d, type_s, conditions_destinationIP_s, conditions_destinationPortRange_s, conditions_sourceIP_s, conditions_sourcePortRange_s, ResourceId
| extend timestamp = StartTime

```

## Suspicious credential token access of valid IAM Roles

'Adversaries may generate temporary credentials of existing privileged IAM roles to access AWS resources that were not previously accessible to perform malicious actions. The credentials may be generated by trusted IAM user or via AWS Cloud Instance Metadata API.
This query will look for AWS STS API Assume Role operations for RoleArn (Role Amazon Resource Names) which was not historically seen.
You can also limit the query to only sensitive IAM Roles which needs to be monitored.
Read more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash 
AWS API AssumeRole at https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html and AWS Instance Metadata API at https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html '

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | AWS |
|DetectionId | 5b6ee21d-da53-46eb-827c-eab2a9ba3d2f |
|DataTypes | AWSCloudTrail |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_SuspiciousCredentialTokenAccessOfValid_IAM_Roles.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
// Generating historical table of AssumeRole operations for IAM Roles to be compared with last 24 hour
AWSCloudTrail
| where TimeGenerated between (starttime..endtime)
| where EventName == "AssumeRole" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)
| project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn
// Doing Leftanti join to find new AssumeRole operation for IAM role which was not seen historically generated from previous table.
| join kind= leftanti
(
  AWSCloudTrail
  | where TimeGenerated  between (lookback..starttime)
  | where EventName == "AssumeRole" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)
  | project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn
) on RoleArn, UserIdentityInvokedBy
| summarize EventCount = count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by RoleArn, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy, SourceIpAddress
| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIpAddress, AccountCustomEntity = tostring(split(RoleArn, "/")[1])

```

## Suspicious credential token access of valid IAM Roles

'Adversaries may generate temporary credentials of existing privileged IAM roles to access AWS resources that were not previously accessible to perform malicious actions. The credentials may be generated by trusted IAM user or via AWS Cloud Instance Metadata API.
This query will look for AWS STS API Assume Role operations for RoleArn (Role Amazon Resource Names) which was not historically seen.
You can also limit the query to only sensitive IAM Roles which needs to be monitored.
Read more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash 
AWS API AssumeRole at https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html and AWS Instance Metadata API at https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html '

|Name | Value |
| --- | --- |
|Tactic | DefenseEvasion|
|TechniqueId | T1078|
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | AWS |
|DetectionId | 5b6ee21d-da53-46eb-827c-eab2a9ba3d2f |
|DataTypes | AWSCloudTrail |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_SuspiciousCredentialTokenAccessOfValid_IAM_Roles.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
// Generating historical table of AssumeRole operations for IAM Roles to be compared with last 24 hour
AWSCloudTrail
| where TimeGenerated between (starttime..endtime)
| where EventName == "AssumeRole" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)
| project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn
// Doing Leftanti join to find new AssumeRole operation for IAM role which was not seen historically generated from previous table.
| join kind= leftanti
(
  AWSCloudTrail
  | where TimeGenerated  between (lookback..starttime)
  | where EventName == "AssumeRole" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)
  | project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn
) on RoleArn, UserIdentityInvokedBy
| summarize EventCount = count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by RoleArn, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy, SourceIpAddress
| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIpAddress, AccountCustomEntity = tostring(split(RoleArn, "/")[1])

```

## Unused or Unsupported Cloud Regions

'Adversaries may create cloud instances in unused geographic service regions in order to evade detection.
Access is usually obtained through compromising accounts used to manage cloud infrastructure.
Refer: https://attack.mitre.org/techniques/T1535/'

|Name | Value |
| --- | --- |
|Tactic | DefenseEvasion|
|TechniqueId | T1535|
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | AWS |
|DetectionId | e0d57543-acbd-428b-bb96-24a67506f84d |
|DataTypes | AWSCloudTrail |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_Unused_UnsupportedCloudRegions.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
// Generating historical table of all events per AccountId and Region
let EventInfo_CurrentDay =  materialize (AWSCloudTrail | where TimeGenerated between(starttime..endtime));
let EventInfo_historical = AWSCloudTrail  | where TimeGenerated  between (lookback..starttime) | summarize max(TimeGenerated) by AWSRegion, UserIdentityAccountId;
// Doing Leftanti join to find new regions historically not seen for the same account.
let EventInfo_Unseen = materialize (
EventInfo_CurrentDay
| summarize max(TimeGenerated) by AWSRegion, UserIdentityAccountId
| join kind= leftanti
(
  EventInfo_historical
) on AWSRegion, UserIdentityAccountId
);
EventInfo_Unseen
// Join Ununsed region seen with current data to gather context about API events seen
| join kind= inner (
   EventInfo_CurrentDay
) on AWSRegion, UserIdentityAccountId
| extend UnusedRegion = AWSRegion
| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))
| summarize EventCount = count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), EventNameList=make_set(EventName), IPList=make_set(SourceIpAddress) by UserIdentityAccountId, UnusedRegion, UserIdentityUserName
| extend timestamp = StartTime , AccountCustomEntity = UserIdentityUserName

```

## Changes made to AWS IAM policy

Identity and Access Management (IAM) securely manages access to AWS services and resources. 
This query looks for when an API call is made to change an IAM, particularly those related to new policies being 
attached to users and roles, as well as changes to access methods and changes to account level policies. 
If these turn out to be noisy filter out the most common for your environment.  

|Name | Value |
| --- | --- |
|Tactic | PrivilegeEscalation|
|TechniqueId | T1078|
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | AWS |
|DetectionId | e0a67cd7-b4e5-4468-aae0-26cb16a1bbd2 |
|DataTypes | AWSCloudTrail |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_IAM_PolicyChange.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AWSCloudTrail
| where  EventName in~ ("AttachGroupPolicy", "AttachRolePolicy", "AttachUserPolicy", "CreatePolicy",
"DeleteGroupPolicy", "DeletePolicy", "DeleteRolePolicy", "DeleteUserPolicy", "DetachGroupPolicy",
"PutUserPolicy", "PutGroupPolicy", "CreatePolicyVersion", "DeletePolicyVersion", "DetachRolePolicy", "CreatePolicy")
| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityAccountId

```

## Changes made to AWS IAM policy

Identity and Access Management (IAM) securely manages access to AWS services and resources. 
This query looks for when an API call is made to change an IAM, particularly those related to new policies being 
attached to users and roles, as well as changes to access methods and changes to account level policies. 
If these turn out to be noisy filter out the most common for your environment.  

|Name | Value |
| --- | --- |
|Tactic | PrivilegeEscalation|
|TechniqueId | T1484|
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | AWS |
|DetectionId | e0a67cd7-b4e5-4468-aae0-26cb16a1bbd2 |
|DataTypes | AWSCloudTrail |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_IAM_PolicyChange.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AWSCloudTrail
| where  EventName in~ ("AttachGroupPolicy", "AttachRolePolicy", "AttachUserPolicy", "CreatePolicy",
"DeleteGroupPolicy", "DeletePolicy", "DeleteRolePolicy", "DeleteUserPolicy", "DetachGroupPolicy",
"PutUserPolicy", "PutGroupPolicy", "CreatePolicyVersion", "DeletePolicyVersion", "DetachRolePolicy", "CreatePolicy")
| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, 
UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityAccountId

```

# Rules: 4579-4599

## Microsoft Sentinel Connectors Administrative Operations

'Identifies set of Microsoft Sentinel Data Connectors administrative operational detection queries for hunting activites'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1496|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 17201aa8-0916-4078-a020-7ea3a9262889 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureSentinelConnectors_AdministrativeOperations.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let opValues = dynamic(["Microsoft.SecurityInsights/dataConnectors/write", "Microsoft.SecurityInsights/dataConnectors/delete"]);
// Microsoft Sentinel Data Connectors Update / Delete
AzureActivity
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in ("Created", "OK")
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | LateralMovement|
|TechniqueId | T1570|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | LateralMovement|
|TechniqueId | T1570|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | LateralMovement|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | LateralMovement|
|TechniqueId | T1078.004|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1570|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1570|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Anomalous Azure Operation Hunting Model

'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
at the top of the query along with the detection window parameters'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1078.004|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 43cb0347-bdcc-4e83-af5a-cebbd03971d8 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// When the detection window will end (3 days prior to now)
let startDetectDate = 3d;
// When the detection window will start (now)
let endDetectDate = 0d;
// When to start collecting data for detection
let startDate = startDetectDate + 30d;
// Operation to monitor, in this case Run Command
let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
// The resource type to monitor, in this case virtual machines
let monitoredResource = pack_array('microsoft.compute/virtualmachines');
let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
{
let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
let countOnScope = T | summarize countAllOnScope = count() by _scope;
let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
    probAB
    | join kind = leftouter (probA) on _A, _scope
    | join kind = leftouter (probB) on _B, _scope
    | extend P_AUB = P_A + P_B - P_AB
           , P_AIB = P_AB/P_B
           , P_BIA = P_AB/P_A
    | extend Lift_AB = P_AB/(P_A * P_B)
           , Jaccard_AB = P_AB/P_AUB
    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
    | sort by _scope, _A, _B
};
let eventsTable = materialize (
AzureActivity
| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
| where isnotempty(CallerIpAddress)
| where ActivityStatusValue has_any ('Success', 'Succeeded')
| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
| extend splitOp = split(OperationNameValue, '/')
| extend splitRes = split(ResourceId, '/')
| project TimeGenerated , subscriptionId=SubscriptionId
            , ResourceProvider
            , ResourceName = tolower(tostring(splitRes[-1]))
            , OperationNameValue = tolower(OperationNameValue)
            , timeSlice = floor(TimeGenerated, 1d)
            , clientIp = tostring(CallerIpAddress)
            , Caller
            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
            , CorrelationId
| extend clientIpMask = format_ipv4_mask(clientIp, 16)
);
let modelData =  (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
    by subscriptionId, Caller, clientIpMask
);
let monOpProbs = materialize (
eventsTable
| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
| where _B == 1
| sort by P_AIB desc
| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
| project-away sumBiggerCondProbs
);
eventsTable
| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
        on subscriptionId, Caller
| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
        on subscriptionId, clientIpMask
| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
        on subscriptionId        
| project-away subscriptionId1, Caller1, subscriptionId2
| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
| project-away _A, _B, _scope
| sort by subscriptionId asc, TimeGenerated asc
| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
| sort by subscriptionId asc, Caller asc, TimeGenerated asc
| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
| order by TimeGenerated
| where isMonitoredOp == 1
// Optional - focus only on monitored operations or monitored resource in detection window
| where isMonitoredOp == 1
//| where isMonitoredResource == 1
```

## Azure CloudShell Usage

'This query look for users starting an Azure CloudShell session and summarizes the Azure Activity from that
user account during that timeframe (by default 1 hour). This can be used to help identify abuse of the CloudShell
to modify Azure resources.'

|Name | Value |
| --- | --- |
|Tactic | Execution|
|TechniqueId | T1059|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 42831fb3-f61d-41e9-95d9-f08797479a0e |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Azure-CloudShell-Usage.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
   | where ActivityStatusValue == "Succeeded"
   | where ResourceGroup has "cloud-shell-storage"
   | where OperationNameValue == "Microsoft.Storage/storageAccounts/listKeys/action"
   // Change the timekey scope below to get activity for a longer window 
   | summarize by Caller, timekey= bin(TimeGenerated, 1h)
   | join (AzureActivity | where TimeGenerated >= ago(1d)
   | where OperationNameValue != "Microsoft.Storage/storageAccounts/listKeys/action"
   | where isnotempty(OperationName)
    // Change the timekey scope below to get activity for a longer window 
   | summarize make_set(OperationName) by Caller, timekey=bin(TimeGenerated, 1h)) on Caller, timekey
   | extend timestamp = timekey, AccountCustomEntity = Caller

```

## Azure CloudShell Usage

'This query look for users starting an Azure CloudShell session and summarizes the Azure Activity from that
user account during that timeframe (by default 1 hour). This can be used to help identify abuse of the CloudShell
to modify Azure resources.'

|Name | Value |
| --- | --- |
|Tactic | Execution|
|TechniqueId | T1059|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 42831fb3-f61d-41e9-95d9-f08797479a0e |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Azure-CloudShell-Usage.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
   | where ActivityStatusValue == "Succeeded"
   | where ResourceGroup has "cloud-shell-storage"
   | where OperationNameValue == "Microsoft.Storage/storageAccounts/listKeys/action"
   // Change the timekey scope below to get activity for a longer window 
   | summarize by Caller, timekey= bin(TimeGenerated, 1h)
   | join (AzureActivity | where TimeGenerated >= ago(1d)
   | where OperationNameValue != "Microsoft.Storage/storageAccounts/listKeys/action"
   | where isnotempty(OperationName)
    // Change the timekey scope below to get activity for a longer window 
   | summarize make_set(OperationName) by Caller, timekey=bin(TimeGenerated, 1h)) on Caller, timekey
   | extend timestamp = timekey, AccountCustomEntity = Caller

```

## Microsoft Sentinel Workbooks Administrative Operations

'Identifies set of Microsoft Sentinel Workbooks administrative operational detection queries for hunting activites'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1496|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 5a1f9655-c893-4091-8dc0-7f11d7676506 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureSentinelWorkbooks_AdministrativeOperation.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let opValues = dynamic(["microsoft.insights/workbooks/write", "microsoft.insights/workbooks/delete"]);
// Microsoft Sentinel Workbook Create / Update / Delete
AzureActivity
| where Category == "Administrative"
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in ("Created", "OK")
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Microsoft Sentinel Workbooks Administrative Operations

'Identifies set of Microsoft Sentinel Workbooks administrative operational detection queries for hunting activites'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1496|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 5a1f9655-c893-4091-8dc0-7f11d7676506 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity | Low |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureSentinelWorkbooks_AdministrativeOperation.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let opValues = dynamic(["microsoft.insights/workbooks/write", "microsoft.insights/workbooks/delete"]);
// Microsoft Sentinel Workbook Create / Update / Delete
AzureActivity
| where Category == "Administrative"
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in ("Created", "OK")
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1571|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1571|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1496|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1496|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1071|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

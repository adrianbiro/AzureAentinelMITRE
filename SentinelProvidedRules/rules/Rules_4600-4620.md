# Rules: 4600-4620

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1571|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1571|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1496|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Port opened for an Azure Resource

'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1496|
|Platform | SaaS|
|DetectionType | Hunting |
|ConnectorId | AzureActivity |
|DetectionId | 9e146876-e303-49af-b847-b029d1a66852 |
|DataTypes | AzureActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

AzureActivity
| where OperationNameValue has_any ("ipfilterrules", "securityRules", "publicIPAddresses", "firewallrules") and OperationNameValue endswith "write"
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue == "Accepted" 
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress

```

## Smart Lockouts

'Identifies accounts that have been locked out by smart lockout policies. Review this results for patterns that might suggest that a password spray is triggering these smart lockout events.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 02e86bf2-172c-4444-ae8e-e94c5ce2bea3 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SmartLockouts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
SigninLogs
| where ResultType == 50053
| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Smart Lockouts

'Identifies accounts that have been locked out by smart lockout policies. Review this results for patterns that might suggest that a password spray is triggering these smart lockout events.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 02e86bf2-172c-4444-ae8e-e94c5ce2bea3 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SmartLockouts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
SigninLogs
| where ResultType == 50053
| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## User Accounts - Blocked Accounts

'An account could be blocked/locked out due to multiple reasons. This hunting query summarize blocked/lockout accounts and checks if most recent signin events for them is after last blocked accounts
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | dbc82bc1-c7df-44e3-838a-5846a313cf35 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-BlockedAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 7d;
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let blocked_users = 
union isfuzzy=true aadSignin, aadNonInt 
// Blocked or locked account due to failed attempts for various reasons.
| where ResultType != "0"
| where ResultDescription has_any ("blocked", "locked")  or ResultType in (50053, 50131, 53003, 500121)
| summarize FirstBlockedAttempt = min(TimeGenerated), LastBlockedAttempt = max(TimeGenerated) by UserPrincipalName, ResultDescription, ResultType;
blocked_users
| join kind= inner (
union isfuzzy=true aadSignin, aadNonInt
| where ResultType == 0
| summarize FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by UserPrincipalName, UserDisplayName
) on UserPrincipalName
| where LastSuccessfulSignin > LastBlockedAttempt //Checking if successul login is after lastblockedattempts
| extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName

```

## User Accounts - Blocked Accounts

'An account could be blocked/locked out due to multiple reasons. This hunting query summarize blocked/lockout accounts and checks if most recent signin events for them is after last blocked accounts
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | dbc82bc1-c7df-44e3-838a-5846a313cf35 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-BlockedAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 7d;
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let blocked_users = 
union isfuzzy=true aadSignin, aadNonInt 
// Blocked or locked account due to failed attempts for various reasons.
| where ResultType != "0"
| where ResultDescription has_any ("blocked", "locked")  or ResultType in (50053, 50131, 53003, 500121)
| summarize FirstBlockedAttempt = min(TimeGenerated), LastBlockedAttempt = max(TimeGenerated) by UserPrincipalName, ResultDescription, ResultType;
blocked_users
| join kind= inner (
union isfuzzy=true aadSignin, aadNonInt
| where ResultType == 0
| summarize FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by UserPrincipalName, UserDisplayName
) on UserPrincipalName
| where LastSuccessfulSignin > LastBlockedAttempt //Checking if successul login is after lastblockedattempts
| extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName

```

## User Accounts - Blocked Accounts

'An account could be blocked/locked out due to multiple reasons. This hunting query summarize blocked/lockout accounts and checks if most recent signin events for them is after last blocked accounts
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | dbc82bc1-c7df-44e3-838a-5846a313cf35 |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-BlockedAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 7d;
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let blocked_users = 
union isfuzzy=true aadSignin, aadNonInt 
// Blocked or locked account due to failed attempts for various reasons.
| where ResultType != "0"
| where ResultDescription has_any ("blocked", "locked")  or ResultType in (50053, 50131, 53003, 500121)
| summarize FirstBlockedAttempt = min(TimeGenerated), LastBlockedAttempt = max(TimeGenerated) by UserPrincipalName, ResultDescription, ResultType;
blocked_users
| join kind= inner (
union isfuzzy=true aadSignin, aadNonInt
| where ResultType == 0
| summarize FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by UserPrincipalName, UserDisplayName
) on UserPrincipalName
| where LastSuccessfulSignin > LastBlockedAttempt //Checking if successul login is after lastblockedattempts
| extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName

```

## User Accounts - Blocked Accounts

'An account could be blocked/locked out due to multiple reasons. This hunting query summarize blocked/lockout accounts and checks if most recent signin events for them is after last blocked accounts
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | dbc82bc1-c7df-44e3-838a-5846a313cf35 |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-BlockedAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 7d;
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let blocked_users = 
union isfuzzy=true aadSignin, aadNonInt 
// Blocked or locked account due to failed attempts for various reasons.
| where ResultType != "0"
| where ResultDescription has_any ("blocked", "locked")  or ResultType in (50053, 50131, 53003, 500121)
| summarize FirstBlockedAttempt = min(TimeGenerated), LastBlockedAttempt = max(TimeGenerated) by UserPrincipalName, ResultDescription, ResultType;
blocked_users
| join kind= inner (
union isfuzzy=true aadSignin, aadNonInt
| where ResultType == 0
| summarize FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by UserPrincipalName, UserDisplayName
) on UserPrincipalName
| where LastSuccessfulSignin > LastBlockedAttempt //Checking if successul login is after lastblockedattempts
| extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName

```

## Administrators Authenticating to Another Azure AD Tenant

'Detects when a privileged user account successfully authenticates from to another Azure AD Tenant.
  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3a0447c1-7f43-43d0-aeac-d5e1247964a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AdministratorsAuthenticatingtoAnotherAzureADTenant.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let admin_users = (IdentityInfo
  | summarize arg_max(TimeGenerated, *) by AccountUPN
  | where AssignedRoles contains "admin"
  | summarize by tolower(AccountUPN));
  SigninLogs
  | where TimeGenerated between(ago(14d)..ago(1d))
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | summarize by UserPrincipalName, ResourceTenantId
  | join kind=rightanti (SigninLogs
  | where TimeGenerated > ago(1d)
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId
  | where RiskLevelAggregated != "none"

```

## Administrators Authenticating to Another Azure AD Tenant

'Detects when a privileged user account successfully authenticates from to another Azure AD Tenant.
  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3a0447c1-7f43-43d0-aeac-d5e1247964a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AdministratorsAuthenticatingtoAnotherAzureADTenant.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let admin_users = (IdentityInfo
  | summarize arg_max(TimeGenerated, *) by AccountUPN
  | where AssignedRoles contains "admin"
  | summarize by tolower(AccountUPN));
  SigninLogs
  | where TimeGenerated between(ago(14d)..ago(1d))
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | summarize by UserPrincipalName, ResourceTenantId
  | join kind=rightanti (SigninLogs
  | where TimeGenerated > ago(1d)
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId
  | where RiskLevelAggregated != "none"

```

## Administrators Authenticating to Another Azure AD Tenant

'Detects when a privileged user account successfully authenticates from to another Azure AD Tenant.
  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | BehaviorAnalytics |
|DetectionId | 3a0447c1-7f43-43d0-aeac-d5e1247964a8 |
|DataTypes | BehaviorAnalytics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AdministratorsAuthenticatingtoAnotherAzureADTenant.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let admin_users = (IdentityInfo
  | summarize arg_max(TimeGenerated, *) by AccountUPN
  | where AssignedRoles contains "admin"
  | summarize by tolower(AccountUPN));
  SigninLogs
  | where TimeGenerated between(ago(14d)..ago(1d))
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | summarize by UserPrincipalName, ResourceTenantId
  | join kind=rightanti (SigninLogs
  | where TimeGenerated > ago(1d)
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId
  | where RiskLevelAggregated != "none"

```

## Administrators Authenticating to Another Azure AD Tenant

'Detects when a privileged user account successfully authenticates from to another Azure AD Tenant.
  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | BehaviorAnalytics |
|DetectionId | 3a0447c1-7f43-43d0-aeac-d5e1247964a8 |
|DataTypes | BehaviorAnalytics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AdministratorsAuthenticatingtoAnotherAzureADTenant.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let admin_users = (IdentityInfo
  | summarize arg_max(TimeGenerated, *) by AccountUPN
  | where AssignedRoles contains "admin"
  | summarize by tolower(AccountUPN));
  SigninLogs
  | where TimeGenerated between(ago(14d)..ago(1d))
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | summarize by UserPrincipalName, ResourceTenantId
  | join kind=rightanti (SigninLogs
  | where TimeGenerated > ago(1d)
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId
  | where RiskLevelAggregated != "none"

```

## Administrators Authenticating to Another Azure AD Tenant

'Detects when a privileged user account successfully authenticates from to another Azure AD Tenant.
  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | BehaviorAnalytics |
|DetectionId | 3a0447c1-7f43-43d0-aeac-d5e1247964a8 |
|DataTypes | BehaviorAnalytics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AdministratorsAuthenticatingtoAnotherAzureADTenant.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let admin_users = (IdentityInfo
  | summarize arg_max(TimeGenerated, *) by AccountUPN
  | where AssignedRoles contains "admin"
  | summarize by tolower(AccountUPN));
  SigninLogs
  | where TimeGenerated between(ago(14d)..ago(1d))
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | summarize by UserPrincipalName, ResourceTenantId
  | join kind=rightanti (SigninLogs
  | where TimeGenerated > ago(1d)
  | where ResultType == 0
  | where tolower(UserPrincipalName) in (admin_users)
  | where HomeTenantId != ResourceTenantId
  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId
  | where RiskLevelAggregated != "none"

```

## User Login IP Address Teleportation

'This query over SiginLogs will identify user accounts that have logged in from two different countries
within a specified time window, by default this is a 10 minute window either side of the previous login.
This query will detect users roaming onto VPNs, it is possible to exclude known VPN IP address ranges.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 09a7c5fc-0649-4f7d-a21b-36a754cef6b6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserLoginIPAddressTeleportation.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let windowTime = 20min / 2; //Window to lookup anomalous logins within
let excludeKnownVPN = dynamic(['127.0.0.1', '0.0.0.0']); //Known VPN IP addresses to exclude
SigninLogs
| where ConditionalAccessStatus =~ "success"
| extend country = LocationDetails['countryOrRegion']
| where country != ""
| summarize count() by tostring(country)
| join (
    //Get the total number of logins from any country and join it to the previous count in a single table
    SigninLogs
    | where ConditionalAccessStatus =~ "success"
    | extend country = LocationDetails['countryOrRegion']
    | where country != ""
    | summarize count(), make_list(tostring(country))
    | mv-expand list_country
    | extend country = tostring(list_country)
) on country
| summarize by country, count_, count_1
//Now calculate each countries prevalence within login events
| extend prevalence = toreal(count_) / toreal(count_1) * 100
| project-away count_1
| where prevalence < 0.01
| join kind=rightsemi(
    SigninLogs
    //Enable to limit to o365 exchange logins
    //| where AppDisplayName =~ "Office 365 Exchange Online"
    | where ConditionalAccessStatus =~ "success"
    | where IPAddress != ""
    | extend country = tostring(LocationDetails['countryOrRegion'])
    | summarize count() by TimeGenerated, UserPrincipalName, country, IPAddress
) on country
| join kind=leftouter (
    SigninLogs
    //Enable to limit to o365 exchange logins
    //| where AppDisplayName =~ "Office 365 Exchange Online"
    | where ConditionalAccessStatus =~ "success"
    | extend country = tostring(LocationDetails['countryOrRegion'])
    | summarize by TimeGenerated, IPAddress, UserPrincipalName, country
) on UserPrincipalName
| where IPAddress != IPAddress1 and country != country1
| extend WindowStart = TimeGenerated1 - windowTime
| extend WindowEnd = TimeGenerated1 + windowTime
| where TimeGenerated between (WindowStart .. WindowEnd)
| project Account=UserPrincipalName, AnomalousIP=IPAddress, AnomalousLoginTime=TimeGenerated, AnomalousCountry=country, OtherLoginIP=IPAddress1, OtherLoginCountry=country1, OtherLoginWindowStart=WindowStart, OtherLoginWindowEnd=WindowEnd
| where AnomalousIP !in(excludeKnownVPN) and OtherLoginIP !in(excludeKnownVPN)
| extend timestamp = AnomalousLoginTime, AccountCustomEntity = Account, IPCustomEntity = AnomalousIP

```

## User Login IP Address Teleportation

'This query over SiginLogs will identify user accounts that have logged in from two different countries
within a specified time window, by default this is a 10 minute window either side of the previous login.
This query will detect users roaming onto VPNs, it is possible to exclude known VPN IP address ranges.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 09a7c5fc-0649-4f7d-a21b-36a754cef6b6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserLoginIPAddressTeleportation.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let windowTime = 20min / 2; //Window to lookup anomalous logins within
let excludeKnownVPN = dynamic(['127.0.0.1', '0.0.0.0']); //Known VPN IP addresses to exclude
SigninLogs
| where ConditionalAccessStatus =~ "success"
| extend country = LocationDetails['countryOrRegion']
| where country != ""
| summarize count() by tostring(country)
| join (
    //Get the total number of logins from any country and join it to the previous count in a single table
    SigninLogs
    | where ConditionalAccessStatus =~ "success"
    | extend country = LocationDetails['countryOrRegion']
    | where country != ""
    | summarize count(), make_list(tostring(country))
    | mv-expand list_country
    | extend country = tostring(list_country)
) on country
| summarize by country, count_, count_1
//Now calculate each countries prevalence within login events
| extend prevalence = toreal(count_) / toreal(count_1) * 100
| project-away count_1
| where prevalence < 0.01
| join kind=rightsemi(
    SigninLogs
    //Enable to limit to o365 exchange logins
    //| where AppDisplayName =~ "Office 365 Exchange Online"
    | where ConditionalAccessStatus =~ "success"
    | where IPAddress != ""
    | extend country = tostring(LocationDetails['countryOrRegion'])
    | summarize count() by TimeGenerated, UserPrincipalName, country, IPAddress
) on country
| join kind=leftouter (
    SigninLogs
    //Enable to limit to o365 exchange logins
    //| where AppDisplayName =~ "Office 365 Exchange Online"
    | where ConditionalAccessStatus =~ "success"
    | extend country = tostring(LocationDetails['countryOrRegion'])
    | summarize by TimeGenerated, IPAddress, UserPrincipalName, country
) on UserPrincipalName
| where IPAddress != IPAddress1 and country != country1
| extend WindowStart = TimeGenerated1 - windowTime
| extend WindowEnd = TimeGenerated1 + windowTime
| where TimeGenerated between (WindowStart .. WindowEnd)
| project Account=UserPrincipalName, AnomalousIP=IPAddress, AnomalousLoginTime=TimeGenerated, AnomalousCountry=country, OtherLoginIP=IPAddress1, OtherLoginCountry=country1, OtherLoginWindowStart=WindowStart, OtherLoginWindowEnd=WindowEnd
| where AnomalousIP !in(excludeKnownVPN) and OtherLoginIP !in(excludeKnownVPN)
| extend timestamp = AnomalousLoginTime, AccountCustomEntity = Account, IPCustomEntity = AnomalousIP

```

## User Accounts - Successful Sign in Spikes

' Identifies measureable increase in successful sign-ins from user accounts.
Spike is determined based on Time series anomaly which will look at historical baseline values.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3c7fcea1-ec9f-4ea2-a555-156073b2d183 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccountsMeasurableincreaseofsuccessfulsignins.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = 14d;
let timeframe = 1d;
let scorethreshold = 5;
let baselinethreshold = 25;
let aadFunc = (tableName:string){
  // Succesful signins.
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(timeframe)))
  | where ResultType == 0
  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let allSignins = union isfuzzy=true aadSignin, aadNonInt ;
let TimeSeriesData = union isfuzzy=true aadSignin, aadNonInt 
| project TimeGenerated, UserPrincipalName
| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by UserPrincipalName
| project  TimeGenerated, UserPrincipalName, HourlyCount;
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')
| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend AnomalyHour = TimeGenerated
| where baseline > baselinethreshold // Filtering low count events per baselinethreshold
| project UserPrincipalName, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;
let AnomalyHours = TimeSeriesAlerts | where TimeGenerated > ago(2d) | project TimeGenerated;
// Filter the alerts for specified timeframe
TimeSeriesAlerts
| where TimeGenerated > ago(2d)
| join kind=inner ( 
union isfuzzy=true aadSignin, aadNonInt
| where TimeGenerated > ago(2d)
| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour
| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours
 | summarize HourlyCount=count(), LatestAnomalyTime = arg_max(timestamp,*) by bin(TimeGenerated,1h),  OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName
) on UserPrincipalName
| project LatestAnomalyTime,  OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, HourlyCount, baseline, anomalies, score
| extend timestamp = LatestAnomalyTime, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName

```

## User Accounts - Successful Sign in Spikes

' Identifies measureable increase in successful sign-ins from user accounts.
Spike is determined based on Time series anomaly which will look at historical baseline values.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3c7fcea1-ec9f-4ea2-a555-156073b2d183 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccountsMeasurableincreaseofsuccessfulsignins.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = 14d;
let timeframe = 1d;
let scorethreshold = 5;
let baselinethreshold = 25;
let aadFunc = (tableName:string){
  // Succesful signins.
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(timeframe)))
  | where ResultType == 0
  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let allSignins = union isfuzzy=true aadSignin, aadNonInt ;
let TimeSeriesData = union isfuzzy=true aadSignin, aadNonInt 
| project TimeGenerated, UserPrincipalName
| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by UserPrincipalName
| project  TimeGenerated, UserPrincipalName, HourlyCount;
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')
| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend AnomalyHour = TimeGenerated
| where baseline > baselinethreshold // Filtering low count events per baselinethreshold
| project UserPrincipalName, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;
let AnomalyHours = TimeSeriesAlerts | where TimeGenerated > ago(2d) | project TimeGenerated;
// Filter the alerts for specified timeframe
TimeSeriesAlerts
| where TimeGenerated > ago(2d)
| join kind=inner ( 
union isfuzzy=true aadSignin, aadNonInt
| where TimeGenerated > ago(2d)
| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour
| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours
 | summarize HourlyCount=count(), LatestAnomalyTime = arg_max(timestamp,*) by bin(TimeGenerated,1h),  OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName
) on UserPrincipalName
| project LatestAnomalyTime,  OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, HourlyCount, baseline, anomalies, score
| extend timestamp = LatestAnomalyTime, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName

```

## User Accounts - Successful Sign in Spikes

' Identifies measureable increase in successful sign-ins from user accounts.
Spike is determined based on Time series anomaly which will look at historical baseline values.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3c7fcea1-ec9f-4ea2-a555-156073b2d183 |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccountsMeasurableincreaseofsuccessfulsignins.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = 14d;
let timeframe = 1d;
let scorethreshold = 5;
let baselinethreshold = 25;
let aadFunc = (tableName:string){
  // Succesful signins.
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(timeframe)))
  | where ResultType == 0
  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
let allSignins = union isfuzzy=true aadSignin, aadNonInt ;
let TimeSeriesData = union isfuzzy=true aadSignin, aadNonInt 
| project TimeGenerated, UserPrincipalName
| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by UserPrincipalName
| project  TimeGenerated, UserPrincipalName, HourlyCount;
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')
| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend AnomalyHour = TimeGenerated
| where baseline > baselinethreshold // Filtering low count events per baselinethreshold
| project UserPrincipalName, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;
let AnomalyHours = TimeSeriesAlerts | where TimeGenerated > ago(2d) | project TimeGenerated;
// Filter the alerts for specified timeframe
TimeSeriesAlerts
| where TimeGenerated > ago(2d)
| join kind=inner ( 
union isfuzzy=true aadSignin, aadNonInt
| where TimeGenerated > ago(2d)
| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour
| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours
 | summarize HourlyCount=count(), LatestAnomalyTime = arg_max(timestamp,*) by bin(TimeGenerated,1h),  OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName
) on UserPrincipalName
| project LatestAnomalyTime,  OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, HourlyCount, baseline, anomalies, score
| extend timestamp = LatestAnomalyTime, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName

```

# Rules: 4642-4662

## Login spike with increase failure rate

'This query over SiginLogs will summarise the total number of login attempts for each hour of the day on week days, this can be edited.
The query then uses Kusto anomaly detection to find login spikes for each hour across all days. The query will then calculate the
percentage change between the anomalous period and the average logins for that period. Finally the query will determine the success
and failure rate for logins for the given 1 hour period, if a specified % change in logins is detected alongside a specified failure rate
a result is presented.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 528c1708-a67e-4e2f-b76d-d5e5e88a22aa |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LoginSpikeWithIncreaseFailureRate.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let failureThreshold = 15;
let percentageChangeThreshold = 50;
SigninLogs
//Collect number of users logging in for each hour
| where TimeGenerated >= lookback
| summarize dcount(UserPrincipalName) by bin(TimeGenerated, 1h)
| extend hour = datetime_part("Hour",TimeGenerated)
| extend day = dayofweek(TimeGenerated)
//Exclude Saturday and Sunday as they skew the data, change depending on your weekend days
| where day != 6d and day != 7d
| order by TimeGenerated asc
//Summarise users trying to authenticate by each hour of the day
| summarize make_list(dcount_UserPrincipalName), make_list(TimeGenerated), avg(dcount_UserPrincipalName), make_list(day) by hour
//Find outlier hours where the number of users trying to authenticate spikes, expand and then keep only anomalous rows
| extend series_decompose_anomalies(list_dcount_UserPrincipalName)
| mv-expand list_dcount_UserPrincipalName, series_decompose_anomalies_list_dcount_UserPrincipalName_ad_flag, list_TimeGenerated, list_day
| where series_decompose_anomalies_list_dcount_UserPrincipalName_ad_flag == 1
//Calculate the percentage change between the spike and the average users authenticating
| project TimeGenerated=todatetime(list_TimeGenerated), Hour=hour, WeekDay=list_day, AccountsAuthenticating=list_dcount_UserPrincipalName, AverageAccountsAuthenticatin=round(avg_dcount_UserPrincipalName, 0), PercentageChange = round  ((list_dcount_UserPrincipalName - avg_dcount_UserPrincipalName) / avg_dcount_UserPrincipalName * 100,   2)
| order by PercentageChange desc
//As an additional feature we collect successful and unsuccessful logins during the 1h windows with anomalies
| join kind=inner(
SigninLogs
| where TimeGenerated >= lookback
| where ResultType == "0"
| summarize Success=dcount(UserPrincipalName), SuccessAccounts=make_set(UserPrincipalName) by bin(TimeGenerated, 1h)
| join kind=inner(
    SigninLogs
    | where TimeGenerated >= lookback
    //Failed sign-ins based on failed username/password combos or failed MFA
    | where ResultType in ("50126", "50074", "50057", "51004")
    | summarize Failed=dcount(UserPrincipalName), FailedAccounts=make_set(UserPrincipalName) by bin(TimeGenerated, 1h)
) on TimeGenerated
| project-away TimeGenerated1
| extend Total = Failed + Success
| project TimeGenerated, SuccessRate = round((toreal(Success) / toreal(Total)) *100) , round(FailureRate = (toreal(Failed) / toreal(Total)) *100), SuccessAccounts, FailedAccounts
) on TimeGenerated
| order by PercentageChange
| project-away TimeGenerated1
//Thresholds, 15% account authentication failure rate at a 50% increase in accounts attempting to authenticate by default
//Comment out line below to see all anomalous results
| where FailureRate >= failureThreshold and PercentageChange >= percentageChangeThreshold
| extend timestamp = TimeGenerated

```

## User Accounts - New Single Factor Auth

'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 8eace93b-f38c-47b7-a21d-739556d31db6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-NewSingleFactorAuth.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let lookback = starttime - 7d;
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
  | where ResultType == 0
  | where AuthenticationDetails != "[]"
  | extend AuthenticationMethod = tostring(todynamic(AuthenticationDetails)[0].authenticationMethod)
  | where AuthenticationMethod != "Previously satisfied"
  | summarize count(), make_set(AuthenticationRequirement), make_set(AuthenticationMethod), make_set(IPAddress), make_set(Location), LastLogin = max(TimeGenerated) by UserPrincipalName
  | extend noofAuthMehods = array_length(set_AuthenticationMethod), noofAuthReqs = array_length(set_AuthenticationRequirement)
  | where noofAuthMehods > 1 or noofAuthReqs > 1
  | extend timestamp = LastLogin, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt 

```

## User Accounts - New Single Factor Auth

'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 8eace93b-f38c-47b7-a21d-739556d31db6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-NewSingleFactorAuth.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let lookback = starttime - 7d;
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
  | where ResultType == 0
  | where AuthenticationDetails != "[]"
  | extend AuthenticationMethod = tostring(todynamic(AuthenticationDetails)[0].authenticationMethod)
  | where AuthenticationMethod != "Previously satisfied"
  | summarize count(), make_set(AuthenticationRequirement), make_set(AuthenticationMethod), make_set(IPAddress), make_set(Location), LastLogin = max(TimeGenerated) by UserPrincipalName
  | extend noofAuthMehods = array_length(set_AuthenticationMethod), noofAuthReqs = array_length(set_AuthenticationRequirement)
  | where noofAuthMehods > 1 or noofAuthReqs > 1
  | extend timestamp = LastLogin, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt 

```

## User Accounts - New Single Factor Auth

'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 8eace93b-f38c-47b7-a21d-739556d31db6 |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-NewSingleFactorAuth.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let lookback = starttime - 7d;
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
  | where ResultType == 0
  | where AuthenticationDetails != "[]"
  | extend AuthenticationMethod = tostring(todynamic(AuthenticationDetails)[0].authenticationMethod)
  | where AuthenticationMethod != "Previously satisfied"
  | summarize count(), make_set(AuthenticationRequirement), make_set(AuthenticationMethod), make_set(IPAddress), make_set(Location), LastLogin = max(TimeGenerated) by UserPrincipalName
  | extend noofAuthMehods = array_length(set_AuthenticationMethod), noofAuthReqs = array_length(set_AuthenticationRequirement)
  | where noofAuthMehods > 1 or noofAuthReqs > 1
  | extend timestamp = LastLogin, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt 

```

## User Accounts - New Single Factor Auth

'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 8eace93b-f38c-47b7-a21d-739556d31db6 |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-NewSingleFactorAuth.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let lookback = starttime - 7d;
let aadFunc = (tableName:string){
  table(tableName)
  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
  | where not(Identity matches regex isGUID)
  | where ResultType == 0
  | where AuthenticationDetails != "[]"
  | extend AuthenticationMethod = tostring(todynamic(AuthenticationDetails)[0].authenticationMethod)
  | where AuthenticationMethod != "Previously satisfied"
  | summarize count(), make_set(AuthenticationRequirement), make_set(AuthenticationMethod), make_set(IPAddress), make_set(Location), LastLogin = max(TimeGenerated) by UserPrincipalName
  | extend noofAuthMehods = array_length(set_AuthenticationMethod), noofAuthReqs = array_length(set_AuthenticationRequirement)
  | where noofAuthMehods > 1 or noofAuthReqs > 1
  | extend timestamp = LastLogin, AccountCustomEntity = UserPrincipalName
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt 

```

## Suspicious Sign-in to Privileged Account

'This query will help detect any Sign-in's from non-compliant device/device registered without MFA(Multi-factor Authentication)/unknown device to privileged account using pre-built watchlist to identify accounts.
Microsoft Sentinel now provides built-in watchlist templates, that can be customized for your environment and used during investigations.
Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/what-s-new-watchlists-templates-are-now-in-public-preview/ba-p/2614340'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | a73c52f2-b3a5-4fe4-be7d-4d59b8558590 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuspiciousSignintoPrivilegedAccount.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let priv_users = ('_GetWatchlist("VIPUsers")') ;
(union isfuzzy=true
(SigninLogs //when a device is registered/joined without MFA 
| where AuthenticationRequirement == "multiFactorAuthentication"
| where ResourceDisplayName == "Device Registration Service" 
| where ConditionalAccessStatus == "success"
| extend AccountName = tolower(split(UserPrincipalName, "@")[0]), WinSecEventDomain = "-"
| where AccountName in (priv_users)
| project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress), 
(
(SigninLogs //Sign-ins by non-compliant devices
| where DeviceDetail.isCompliant == false
| where ConditionalAccessStatus == "success"
  | extend AccountName = tolower(split(UserPrincipalName, "@")[0]), WinSecEventDomain = "-"
  | where AccountName in (priv_users)
  | project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)
),
(SigninLogs //Sign-ins by unknown devices
| where isempty(DeviceDetail.deviceId)
| where AuthenticationRequirement == "singleFactorAuthentication"
| where ResultType == "0"
| where NetworkLocationDetails == "[]"
| extend AccountName = tolower(split(UserPrincipalName, "@")[0]), WinSecEventDomain = "-"
| where AccountName in (priv_users)
| project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)
)
| project AccountCustomEntity = AccountName, AppId, Category, IPCustomEntity = ClientIP, CorrelationId, ResourceCustomEntity = ResourceId, Identity

```

## Suspicious Sign-in to Privileged Account

'This query will help detect any Sign-in's from non-compliant device/device registered without MFA(Multi-factor Authentication)/unknown device to privileged account using pre-built watchlist to identify accounts.
Microsoft Sentinel now provides built-in watchlist templates, that can be customized for your environment and used during investigations.
Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/what-s-new-watchlists-templates-are-now-in-public-preview/ba-p/2614340'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | a73c52f2-b3a5-4fe4-be7d-4d59b8558590 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuspiciousSignintoPrivilegedAccount.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let priv_users = ('_GetWatchlist("VIPUsers")') ;
(union isfuzzy=true
(SigninLogs //when a device is registered/joined without MFA 
| where AuthenticationRequirement == "multiFactorAuthentication"
| where ResourceDisplayName == "Device Registration Service" 
| where ConditionalAccessStatus == "success"
| extend AccountName = tolower(split(UserPrincipalName, "@")[0]), WinSecEventDomain = "-"
| where AccountName in (priv_users)
| project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress), 
(
(SigninLogs //Sign-ins by non-compliant devices
| where DeviceDetail.isCompliant == false
| where ConditionalAccessStatus == "success"
  | extend AccountName = tolower(split(UserPrincipalName, "@")[0]), WinSecEventDomain = "-"
  | where AccountName in (priv_users)
  | project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)
),
(SigninLogs //Sign-ins by unknown devices
| where isempty(DeviceDetail.deviceId)
| where AuthenticationRequirement == "singleFactorAuthentication"
| where ResultType == "0"
| where NetworkLocationDetails == "[]"
| extend AccountName = tolower(split(UserPrincipalName, "@")[0]), WinSecEventDomain = "-"
| where AccountName in (priv_users)
| project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)
)
| project AccountCustomEntity = AccountName, AppId, Category, IPCustomEntity = ClientIP, CorrelationId, ResourceCustomEntity = ResourceId, Identity

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1110|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1110|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1110.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1110.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1110.003|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1110.003|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

## Low & slow password attempts with volatile IP addresses

'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses
 Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise 
 the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP 
 addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.
 Reduce the timeRange if you have too much data. Results with the highest "IPs", "Failures" and "DaysWithAttempts" are good candidates for further
 investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 3d217bb4-9cc2-4aba-838a-48e606e910e6 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let timeRange = 365d;
let UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.
SigninLogs
| where TimeGenerated between(starttime..endtime)
// Limit to username/password failure errors, most common when bruteforcing/spraying
| where ResultType has_any("50055","50126")
// Find instances where an IP has only been used once
| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName 
| where IPLogins == 1
// We only keep instances where there is 1 event, so we know there will only be one datetime in the list
| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')
// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName
) on $left.IPAddress == $right.IPAddress
// Where there have been fewer than 2 successful logins from the IP
| where count_ < 2 or isempty(count_)
// Confirm that the result is for the same account where possible
| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)
// Summarize the collected details around the users email address
| mv-expand list_TimeGenerated to typeof(datetime)
| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName
| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location
// Join back to get countries the user has successfully authenticated from to compare with failures
| join kind=leftouter (
    SigninLogs
    | where TimeGenerated > ago(timeRange)
    | where ResultType == 0
    // If there is no location make the output pretty
    | extend Location = iff(isempty(Location), "NODATA", Location)
    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName
) on $left.UserPrincipalName == $right.UserPrincipalName
| project-away UserPrincipalName1
| order by UnsuccessfulLoginCountryCount desc
// Calculate the difference between countries with successful vs. failed logins
| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount
// The below line can be removed if the actor is using IPs in one country
| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold
| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses

```

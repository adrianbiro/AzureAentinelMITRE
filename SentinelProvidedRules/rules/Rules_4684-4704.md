# Rules: 4684-4704

## Sign-ins from IPs that attempt sign-ins to disabled accounts

'Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.
This analytic will additionally identify the successful signed in accounts as the mapped account entities for investigation.
References: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
50057 - User account is disabled. The account has been disabled by an administrator.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1098|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 53b6d42e-ff74-46a8-abee-ec72181f66ba |
|DataTypes | SigninLogs |
|QueryFrequency | 1d |
|QueryPeriod | 1d |
|TriggerOperator | gt |
|TriggerThreshold | 0.0 |
|DetectionSeverity | Medium |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessfulAccount-SigninAttemptsByIPviaDisabledAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let threshold = 100;
SigninLogs 
| where ResultType == "50057" 
| where ResultDescription == "User account is disabled. The account has been disabled by an administrator." 
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), disabledAccountLoginAttempts = count(), 
disabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = makeset(UserPrincipalName), 
applicationSet = makeset(AppDisplayName) by IPAddress
| order by disabledAccountLoginAttempts desc
| join kind= leftouter (
    // Consider these IPs suspicious - and alert any related  successful sign-ins
    SigninLogs
    | where ResultType == 0
    | summarize successSigninStart = min(TimeGenerated), successSigninEnd = max(TimeGenerated), successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = makeset(UserPrincipalName, 15) by IPAddress
    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe
    | where successfulAccountSigninCount < threshold
) on IPAddress  
// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account
| where successfulAccountSigninCount != 0
// Successful Account Signins occur within the same lookback period as the failed 
| extend SuccessBeforeFailure = iff(successSigninStart >= StartTime and successSigninEnd <= EndTime, true, false)  
| project StartTime, EndTime, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, 
successfulAccountSigninCount, successfulAccountSigninSet
| order by disabledAccountLoginAttempts
// Break up the string of Succesfully signed into accounts into individual events
| mvexpand successfulAccountSigninSet
| extend timestamp = StartTime, IPCustomEntity = IPAddress

```

## Risky Sign-in with Device Registration

'Looks for new device registrations following a risky user account sign-in. By default the
query will use a 6 hour lookback period, this can be configured within the query.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | f9f8b17c-52ed-4fd1-8edd-6278b6e2669f |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithDeviceRegistration.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let registeredDevices=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Add registered owner to device" 
| where Identity =~ "Device Registration Service" 
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| extend DeviceObjectId = trim('"', tostring(TargetResources[0].modifiedProperties[0].newValue))
| extend DeviceDisplayName = trim('"', tostring(TargetResources[0].modifiedProperties[1].newValue))
| project DeviceRegistrationTimestamp=TimeGenerated,CorrelationId,AccountUpn,AccountObjectId,DeviceObjectId,DeviceDisplayName;
let registeringUser= 
registeredDevices 
| distinct AccountObjectId;
let hasRegisteringUser = isnotempty(toscalar(registeringUser));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasRegisteringUser
| where UserId in (registeringUser) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
registeredDevices 
| join riskySignins on AccountObjectId 
| where DeviceRegistrationTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = DeviceRegistrationTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Risky Sign-in with Device Registration

'Looks for new device registrations following a risky user account sign-in. By default the
query will use a 6 hour lookback period, this can be configured within the query.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | f9f8b17c-52ed-4fd1-8edd-6278b6e2669f |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithDeviceRegistration.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let registeredDevices=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Add registered owner to device" 
| where Identity =~ "Device Registration Service" 
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| extend DeviceObjectId = trim('"', tostring(TargetResources[0].modifiedProperties[0].newValue))
| extend DeviceDisplayName = trim('"', tostring(TargetResources[0].modifiedProperties[1].newValue))
| project DeviceRegistrationTimestamp=TimeGenerated,CorrelationId,AccountUpn,AccountObjectId,DeviceObjectId,DeviceDisplayName;
let registeringUser= 
registeredDevices 
| distinct AccountObjectId;
let hasRegisteringUser = isnotempty(toscalar(registeringUser));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasRegisteringUser
| where UserId in (registeringUser) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
registeredDevices 
| join riskySignins on AccountObjectId 
| where DeviceRegistrationTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = DeviceRegistrationTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Risky Sign-in with Device Registration

'Looks for new device registrations following a risky user account sign-in. By default the
query will use a 6 hour lookback period, this can be configured within the query.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | f9f8b17c-52ed-4fd1-8edd-6278b6e2669f |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithDeviceRegistration.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let registeredDevices=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Add registered owner to device" 
| where Identity =~ "Device Registration Service" 
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| extend DeviceObjectId = trim('"', tostring(TargetResources[0].modifiedProperties[0].newValue))
| extend DeviceDisplayName = trim('"', tostring(TargetResources[0].modifiedProperties[1].newValue))
| project DeviceRegistrationTimestamp=TimeGenerated,CorrelationId,AccountUpn,AccountObjectId,DeviceObjectId,DeviceDisplayName;
let registeringUser= 
registeredDevices 
| distinct AccountObjectId;
let hasRegisteringUser = isnotempty(toscalar(registeringUser));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasRegisteringUser
| where UserId in (registeringUser) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
registeredDevices 
| join riskySignins on AccountObjectId 
| where DeviceRegistrationTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = DeviceRegistrationTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Risky Sign-in with Device Registration

'Looks for new device registrations following a risky user account sign-in. By default the
query will use a 6 hour lookback period, this can be configured within the query.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | f9f8b17c-52ed-4fd1-8edd-6278b6e2669f |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithDeviceRegistration.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let registeredDevices=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Add registered owner to device" 
| where Identity =~ "Device Registration Service" 
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| extend DeviceObjectId = trim('"', tostring(TargetResources[0].modifiedProperties[0].newValue))
| extend DeviceDisplayName = trim('"', tostring(TargetResources[0].modifiedProperties[1].newValue))
| project DeviceRegistrationTimestamp=TimeGenerated,CorrelationId,AccountUpn,AccountObjectId,DeviceObjectId,DeviceDisplayName;
let registeringUser= 
registeredDevices 
| distinct AccountObjectId;
let hasRegisteringUser = isnotempty(toscalar(registeringUser));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasRegisteringUser
| where UserId in (registeringUser) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
registeredDevices 
| join riskySignins on AccountObjectId 
| where DeviceRegistrationTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = DeviceRegistrationTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Successful Signin From Non-Compliant Device

'Detects successful sign ins from devices marked non-compliant.
  Best practice is to block sign ins from non-complaint devices, however if allowed monitor these events to ensure they do not lead to other risky activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-devices#non-compliant-device-sign-in'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 99885ff5-00cf-49e8-9452-6de6aba2a5c7 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessfulSigninFromNon-CompliantDevice.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
SigninLogs
  | where ResultType == 0
  | where tostring(DeviceDetail.isCompliant) == "false"

```

## Successful Signin From Non-Compliant Device

'Detects successful sign ins from devices marked non-compliant.
  Best practice is to block sign ins from non-complaint devices, however if allowed monitor these events to ensure they do not lead to other risky activity.
  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-devices#non-compliant-device-sign-in'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 99885ff5-00cf-49e8-9452-6de6aba2a5c7 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessfulSigninFromNon-CompliantDevice.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
SigninLogs
  | where ResultType == 0
  | where tostring(DeviceDetail.isCompliant) == "false"

```

## Anomalous sign-in location by user account and authenticating application

'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
Directory application and picks out the most anomalous change in location profile for a user within an 
individual application. The intent is to hunt for user account compromise, possibly via a specific application
vector.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 8159c663-6724-41b8-9ae8-b328aa8d0c4c |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AnomalousUserAppSigninLocationIncrease.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| extend  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", 
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";") 
| project TimeGenerated, AppDisplayName, UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated step 1d
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare, Slope, Variance, RVariance, Interception, LineFit) = series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName 
| render timechart

```

## Anomalous sign-in location by user account and authenticating application

'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
Directory application and picks out the most anomalous change in location profile for a user within an 
individual application. The intent is to hunt for user account compromise, possibly via a specific application
vector.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 8159c663-6724-41b8-9ae8-b328aa8d0c4c |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AnomalousUserAppSigninLocationIncrease.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| extend  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", 
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";") 
| project TimeGenerated, AppDisplayName, UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated step 1d
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare, Slope, Variance, RVariance, Interception, LineFit) = series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName 
| render timechart

```

## Suspected Brute force attack Investigation

'Summarize all the failures and success events for all users in the last 24 hours, 
only identify users with more than 100 failures in the set period'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 056ceb9b-8f07-42b3-853e-ef3779de222e |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AADSuspectedBruteForce.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let successCodes = dynamic(["0", "50125", "50140", "70043", "70044"]);
let aadFunc = (tableName:string){
  table(tableName)
 | extend FailureOrSuccess = iff(ResultType in (successCodes), "Success", "Failure")
 | summarize FailureCount = countif(FailureOrSuccess=="Failure"), SuccessCount = countif(FailureOrSuccess=="Success") by bin(TimeGenerated, 1h),UserPrincipalName, UserDisplayName, IPAddress
 | where FailureCount > 100
 | where SuccessCount > 0
 | order by UserPrincipalName, TimeGenerated asc
 | extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt

```

## Suspected Brute force attack Investigation

'Summarize all the failures and success events for all users in the last 24 hours, 
only identify users with more than 100 failures in the set period'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 056ceb9b-8f07-42b3-853e-ef3779de222e |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AADSuspectedBruteForce.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let successCodes = dynamic(["0", "50125", "50140", "70043", "70044"]);
let aadFunc = (tableName:string){
  table(tableName)
 | extend FailureOrSuccess = iff(ResultType in (successCodes), "Success", "Failure")
 | summarize FailureCount = countif(FailureOrSuccess=="Failure"), SuccessCount = countif(FailureOrSuccess=="Success") by bin(TimeGenerated, 1h),UserPrincipalName, UserDisplayName, IPAddress
 | where FailureCount > 100
 | where SuccessCount > 0
 | order by UserPrincipalName, TimeGenerated asc
 | extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt

```

## Suspected Brute force attack Investigation

'Summarize all the failures and success events for all users in the last 24 hours, 
only identify users with more than 100 failures in the set period'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 056ceb9b-8f07-42b3-853e-ef3779de222e |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AADSuspectedBruteForce.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let successCodes = dynamic(["0", "50125", "50140", "70043", "70044"]);
let aadFunc = (tableName:string){
  table(tableName)
 | extend FailureOrSuccess = iff(ResultType in (successCodes), "Success", "Failure")
 | summarize FailureCount = countif(FailureOrSuccess=="Failure"), SuccessCount = countif(FailureOrSuccess=="Success") by bin(TimeGenerated, 1h),UserPrincipalName, UserDisplayName, IPAddress
 | where FailureCount > 100
 | where SuccessCount > 0
 | order by UserPrincipalName, TimeGenerated asc
 | extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt

```

## Suspected Brute force attack Investigation

'Summarize all the failures and success events for all users in the last 24 hours, 
only identify users with more than 100 failures in the set period'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 056ceb9b-8f07-42b3-853e-ef3779de222e |
|DataTypes | AADNonInteractiveUserSignInLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AADSuspectedBruteForce.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let successCodes = dynamic(["0", "50125", "50140", "70043", "70044"]);
let aadFunc = (tableName:string){
  table(tableName)
 | extend FailureOrSuccess = iff(ResultType in (successCodes), "Success", "Failure")
 | summarize FailureCount = countif(FailureOrSuccess=="Failure"), SuccessCount = countif(FailureOrSuccess=="Success") by bin(TimeGenerated, 1h),UserPrincipalName, UserDisplayName, IPAddress
 | where FailureCount > 100
 | where SuccessCount > 0
 | order by UserPrincipalName, TimeGenerated asc
 | extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
};
let aadSignin = aadFunc("SigninLogs");
let aadNonInt = aadFunc("AADNonInteractiveUserSignInLogs");
union isfuzzy=true aadSignin, aadNonInt

```

## User Accounts - Unusual authentications occurring when countries do not conduct normal business operations.

'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | f56b2223-0d4d-4347-9de4-822d195624ee |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-UnusualLogonTimes.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let userthreshold = 25;
let HistLogons = SigninLogs
| where IsInteractive == true
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)
| extend DayofWeek = case(
  DayNumberofWeek == "00:00:00", "Sunday", 
  DayNumberofWeek == "1.00:00:00", "Monday", 
  DayNumberofWeek == "2.00:00:00", "Tuesday", 
  DayNumberofWeek == "3.00:00:00", "Wednesday", 
  DayNumberofWeek == "4.00:00:00", "Thursday", 
  DayNumberofWeek == "5.00:00:00", "Friday", 
  DayNumberofWeek == "6.00:00:00", "Saturday","InvalidTimeStamp")
| summarize UserCount = dcount(UserPrincipalName) by HourOfLogin, Location, DayofWeek
| where UserCount > userthreshold;
HistLogons
| join kind = rightanti (
SigninLogs
| where IsInteractive == true
| where TimeGenerated > ago(1d)
| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)
| extend DayofWeek = case(
  DayNumberofWeek == "00:00:00", "Sunday", 
  DayNumberofWeek == "1.00:00:00", "Monday", 
  DayNumberofWeek == "2.00:00:00", "Tuesday", 
  DayNumberofWeek == "3.00:00:00", "Wednesday", 
  DayNumberofWeek == "4.00:00:00", "Thursday", 
  DayNumberofWeek == "5.00:00:00", "Friday", 
  DayNumberofWeek == "6.00:00:00", "Saturday","InvalidTimeStamp")
  | summarize count(), FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by HourOfLogin, Location, DayofWeek, UserPrincipalName
  ) on Location, DayofWeek , HourOfLogin
  | extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName

```

## User Accounts - Unusual authentications occurring when countries do not conduct normal business operations.

'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.
Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | f56b2223-0d4d-4347-9de4-822d195624ee |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-UnusualLogonTimes.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let userthreshold = 25;
let HistLogons = SigninLogs
| where IsInteractive == true
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)
| extend DayofWeek = case(
  DayNumberofWeek == "00:00:00", "Sunday", 
  DayNumberofWeek == "1.00:00:00", "Monday", 
  DayNumberofWeek == "2.00:00:00", "Tuesday", 
  DayNumberofWeek == "3.00:00:00", "Wednesday", 
  DayNumberofWeek == "4.00:00:00", "Thursday", 
  DayNumberofWeek == "5.00:00:00", "Friday", 
  DayNumberofWeek == "6.00:00:00", "Saturday","InvalidTimeStamp")
| summarize UserCount = dcount(UserPrincipalName) by HourOfLogin, Location, DayofWeek
| where UserCount > userthreshold;
HistLogons
| join kind = rightanti (
SigninLogs
| where IsInteractive == true
| where TimeGenerated > ago(1d)
| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)
| extend DayofWeek = case(
  DayNumberofWeek == "00:00:00", "Sunday", 
  DayNumberofWeek == "1.00:00:00", "Monday", 
  DayNumberofWeek == "2.00:00:00", "Tuesday", 
  DayNumberofWeek == "3.00:00:00", "Wednesday", 
  DayNumberofWeek == "4.00:00:00", "Thursday", 
  DayNumberofWeek == "5.00:00:00", "Friday", 
  DayNumberofWeek == "6.00:00:00", "Saturday","InvalidTimeStamp")
  | summarize count(), FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by HourOfLogin, Location, DayofWeek, UserPrincipalName
  ) on Location, DayofWeek , HourOfLogin
  | extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName

```

## Multiple AAD Admins Removed

'Looks for multiple users that had their admin role removed by a single user within a certain period.
The default threshold is 5 removals, this can be edited in the query.'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1531|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 18793540-3b93-4a7f-8e30-871291a1c6cf |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/multipleAADAdminRemovals.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let removedAccountsThreshold = 5;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName in~ ("Remove member from role", "Remove eligible member from role")
| where Identity !has "MS-PIM"
| extend roleName = trim('"' , tostring(TargetResources[0].modifiedProperties[1].oldValue))
| where roleName in~ ("Company Administrator", "Global Administrator") // Add more roles you found interesting here
| where TargetResources[0].type =~ "User"
| extend Actor = tostring(TargetResources[0].id), removedUserUpn = tostring(TargetResources[0].userPrincipalName)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), removedAccounts = dcount(removedUserUpn), removedUserUPN=make_set(removedUserUpn) by Actor
| where removedAccounts > removedAccountsThreshold
| extend timestamp = StartTime, AccountCustomEntity = Actor

```

## Multiple AAD Admins Removed

'Looks for multiple users that had their admin role removed by a single user within a certain period.
The default threshold is 5 removals, this can be edited in the query.'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | T1531|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 18793540-3b93-4a7f-8e30-871291a1c6cf |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/multipleAADAdminRemovals.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let removedAccountsThreshold = 5;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName in~ ("Remove member from role", "Remove eligible member from role")
| where Identity !has "MS-PIM"
| extend roleName = trim('"' , tostring(TargetResources[0].modifiedProperties[1].oldValue))
| where roleName in~ ("Company Administrator", "Global Administrator") // Add more roles you found interesting here
| where TargetResources[0].type =~ "User"
| extend Actor = tostring(TargetResources[0].id), removedUserUpn = tostring(TargetResources[0].userPrincipalName)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), removedAccounts = dcount(removedUserUpn), removedUserUPN=make_set(removedUserUpn) by Actor
| where removedAccounts > removedAccountsThreshold
| extend timestamp = StartTime, AccountCustomEntity = Actor

```

## Inactive or new account signins

'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted 
but were not and may have been subsequently compromised.
UEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.
Results for user accounts created in the last 7 days are filtered out.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 847c2652-547d-4d5f-9b71-d2f8d81eac62 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let midtime = starttime - 7d;
let SigninsSummary = SigninLogs
| where TimeGenerated between(starttime..endtime)
// successful sign-in only
| where ResultType == 0
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated between(lookback..starttime)
   | where ResultType == 0
   | summarize by UserId
) on UserId;
// need to help BehaviorAnalytics query to limit only to Signins we are interested in
let onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);
let SigninsWithUEBA =
BehaviorAnalytics
| where TimeGenerated between(starttime..endtime)
| where ActionType in ('Sign-in','InteractiveLogon')
| where UserPrincipalName in~ (onlyInactive)
| extend ActivityInsights = parse_xml(ActivityInsights)
// only looked where FirstTimeUser items are True
| where ActivityInsights matches regex '\"FirstTimeUser([A-Za-z0-9]+)\":\"True\"'
// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True
// also always keep InvestigationPriority if 1 or more
| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.
| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)
| extend UEBA_Insights = pack_dictionary("TimeGenerated", TimeGenerated, "ActivityInsights", ActivityInsights, "UsersInsights", UsersInsights, "DevicesInsights", DevicesInsights)
| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by
UEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority
| extend UEBA_Info = pack_dictionary("UEBA_Insights", UEBA_Insights, "UEBA_ItemIds", UEBA_ItemIds, "UEBA_SourceRecordIds", UEBA_SourceRecordIds)
| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights
| join kind=inner ( 
  SigninsSummary
) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress
| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType
;
SigninsWithUEBA 
| join kind= leftanti (
   // filter out newly created user accounts from last 7 days
   AuditLogs
   | where TimeGenerated between(midtime..endtime)
   | where OperationName == "Add user"
   | summarize by NewUserId = tostring(TargetResources[0].id)
) on $left.UserId == $right.NewUserId
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Inactive or new account signins

'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted 
but were not and may have been subsequently compromised.
UEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.
Results for user accounts created in the last 7 days are filtered out.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 847c2652-547d-4d5f-9b71-d2f8d81eac62 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let midtime = starttime - 7d;
let SigninsSummary = SigninLogs
| where TimeGenerated between(starttime..endtime)
// successful sign-in only
| where ResultType == 0
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated between(lookback..starttime)
   | where ResultType == 0
   | summarize by UserId
) on UserId;
// need to help BehaviorAnalytics query to limit only to Signins we are interested in
let onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);
let SigninsWithUEBA =
BehaviorAnalytics
| where TimeGenerated between(starttime..endtime)
| where ActionType in ('Sign-in','InteractiveLogon')
| where UserPrincipalName in~ (onlyInactive)
| extend ActivityInsights = parse_xml(ActivityInsights)
// only looked where FirstTimeUser items are True
| where ActivityInsights matches regex '\"FirstTimeUser([A-Za-z0-9]+)\":\"True\"'
// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True
// also always keep InvestigationPriority if 1 or more
| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.
| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)
| extend UEBA_Insights = pack_dictionary("TimeGenerated", TimeGenerated, "ActivityInsights", ActivityInsights, "UsersInsights", UsersInsights, "DevicesInsights", DevicesInsights)
| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by
UEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority
| extend UEBA_Info = pack_dictionary("UEBA_Insights", UEBA_Insights, "UEBA_ItemIds", UEBA_ItemIds, "UEBA_SourceRecordIds", UEBA_SourceRecordIds)
| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights
| join kind=inner ( 
  SigninsSummary
) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress
| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType
;
SigninsWithUEBA 
| join kind= leftanti (
   // filter out newly created user accounts from last 7 days
   AuditLogs
   | where TimeGenerated between(midtime..endtime)
   | where OperationName == "Add user"
   | summarize by NewUserId = tostring(TargetResources[0].id)
) on $left.UserId == $right.NewUserId
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Inactive or new account signins

'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted 
but were not and may have been subsequently compromised.
UEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.
Results for user accounts created in the last 7 days are filtered out.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 847c2652-547d-4d5f-9b71-d2f8d81eac62 |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let midtime = starttime - 7d;
let SigninsSummary = SigninLogs
| where TimeGenerated between(starttime..endtime)
// successful sign-in only
| where ResultType == 0
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated between(lookback..starttime)
   | where ResultType == 0
   | summarize by UserId
) on UserId;
// need to help BehaviorAnalytics query to limit only to Signins we are interested in
let onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);
let SigninsWithUEBA =
BehaviorAnalytics
| where TimeGenerated between(starttime..endtime)
| where ActionType in ('Sign-in','InteractiveLogon')
| where UserPrincipalName in~ (onlyInactive)
| extend ActivityInsights = parse_xml(ActivityInsights)
// only looked where FirstTimeUser items are True
| where ActivityInsights matches regex '\"FirstTimeUser([A-Za-z0-9]+)\":\"True\"'
// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True
// also always keep InvestigationPriority if 1 or more
| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.
| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)
| extend UEBA_Insights = pack_dictionary("TimeGenerated", TimeGenerated, "ActivityInsights", ActivityInsights, "UsersInsights", UsersInsights, "DevicesInsights", DevicesInsights)
| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by
UEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority
| extend UEBA_Info = pack_dictionary("UEBA_Insights", UEBA_Insights, "UEBA_ItemIds", UEBA_ItemIds, "UEBA_SourceRecordIds", UEBA_SourceRecordIds)
| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights
| join kind=inner ( 
  SigninsSummary
) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress
| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType
;
SigninsWithUEBA 
| join kind= leftanti (
   // filter out newly created user accounts from last 7 days
   AuditLogs
   | where TimeGenerated between(midtime..endtime)
   | where OperationName == "Add user"
   | summarize by NewUserId = tostring(TargetResources[0].id)
) on $left.UserId == $right.NewUserId
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

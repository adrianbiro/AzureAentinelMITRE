# Rules: 4705-4725

## Inactive or new account signins

'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted 
but were not and may have been subsequently compromised.
UEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.
Results for user accounts created in the last 7 days are filtered out.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | BehaviorAnalytics |
|DetectionId | 847c2652-547d-4d5f-9b71-d2f8d81eac62 |
|DataTypes | BehaviorAnalytics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let midtime = starttime - 7d;
let SigninsSummary = SigninLogs
| where TimeGenerated between(starttime..endtime)
// successful sign-in only
| where ResultType == 0
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated between(lookback..starttime)
   | where ResultType == 0
   | summarize by UserId
) on UserId;
// need to help BehaviorAnalytics query to limit only to Signins we are interested in
let onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);
let SigninsWithUEBA =
BehaviorAnalytics
| where TimeGenerated between(starttime..endtime)
| where ActionType in ('Sign-in','InteractiveLogon')
| where UserPrincipalName in~ (onlyInactive)
| extend ActivityInsights = parse_xml(ActivityInsights)
// only looked where FirstTimeUser items are True
| where ActivityInsights matches regex '\"FirstTimeUser([A-Za-z0-9]+)\":\"True\"'
// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True
// also always keep InvestigationPriority if 1 or more
| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.
| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)
| extend UEBA_Insights = pack_dictionary("TimeGenerated", TimeGenerated, "ActivityInsights", ActivityInsights, "UsersInsights", UsersInsights, "DevicesInsights", DevicesInsights)
| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by
UEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority
| extend UEBA_Info = pack_dictionary("UEBA_Insights", UEBA_Insights, "UEBA_ItemIds", UEBA_ItemIds, "UEBA_SourceRecordIds", UEBA_SourceRecordIds)
| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights
| join kind=inner ( 
  SigninsSummary
) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress
| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType
;
SigninsWithUEBA 
| join kind= leftanti (
   // filter out newly created user accounts from last 7 days
   AuditLogs
   | where TimeGenerated between(midtime..endtime)
   | where OperationName == "Add user"
   | summarize by NewUserId = tostring(TargetResources[0].id)
) on $left.UserId == $right.NewUserId
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Inactive or new account signins

'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted 
but were not and may have been subsequently compromised.
UEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.
Results for user accounts created in the last 7 days are filtered out.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | BehaviorAnalytics |
|DetectionId | 847c2652-547d-4d5f-9b71-d2f8d81eac62 |
|DataTypes | BehaviorAnalytics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let midtime = starttime - 7d;
let SigninsSummary = SigninLogs
| where TimeGenerated between(starttime..endtime)
// successful sign-in only
| where ResultType == 0
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated between(lookback..starttime)
   | where ResultType == 0
   | summarize by UserId
) on UserId;
// need to help BehaviorAnalytics query to limit only to Signins we are interested in
let onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);
let SigninsWithUEBA =
BehaviorAnalytics
| where TimeGenerated between(starttime..endtime)
| where ActionType in ('Sign-in','InteractiveLogon')
| where UserPrincipalName in~ (onlyInactive)
| extend ActivityInsights = parse_xml(ActivityInsights)
// only looked where FirstTimeUser items are True
| where ActivityInsights matches regex '\"FirstTimeUser([A-Za-z0-9]+)\":\"True\"'
// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True
// also always keep InvestigationPriority if 1 or more
| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.
| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)
| extend UEBA_Insights = pack_dictionary("TimeGenerated", TimeGenerated, "ActivityInsights", ActivityInsights, "UsersInsights", UsersInsights, "DevicesInsights", DevicesInsights)
| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by
UEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority
| extend UEBA_Info = pack_dictionary("UEBA_Insights", UEBA_Insights, "UEBA_ItemIds", UEBA_ItemIds, "UEBA_SourceRecordIds", UEBA_SourceRecordIds)
| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights
| join kind=inner ( 
  SigninsSummary
) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress
| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType
;
SigninsWithUEBA 
| join kind= leftanti (
   // filter out newly created user accounts from last 7 days
   AuditLogs
   | where TimeGenerated between(midtime..endtime)
   | where OperationName == "Add user"
   | summarize by NewUserId = tostring(TargetResources[0].id)
) on $left.UserId == $right.NewUserId
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Inactive or new account signins

'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted 
but were not and may have been subsequently compromised.
UEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.
Results for user accounts created in the last 7 days are filtered out.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | BehaviorAnalytics |
|DetectionId | 847c2652-547d-4d5f-9b71-d2f8d81eac62 |
|DataTypes | BehaviorAnalytics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let midtime = starttime - 7d;
let SigninsSummary = SigninLogs
| where TimeGenerated between(starttime..endtime)
// successful sign-in only
| where ResultType == 0
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated between(lookback..starttime)
   | where ResultType == 0
   | summarize by UserId
) on UserId;
// need to help BehaviorAnalytics query to limit only to Signins we are interested in
let onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);
let SigninsWithUEBA =
BehaviorAnalytics
| where TimeGenerated between(starttime..endtime)
| where ActionType in ('Sign-in','InteractiveLogon')
| where UserPrincipalName in~ (onlyInactive)
| extend ActivityInsights = parse_xml(ActivityInsights)
// only looked where FirstTimeUser items are True
| where ActivityInsights matches regex '\"FirstTimeUser([A-Za-z0-9]+)\":\"True\"'
// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True
// also always keep InvestigationPriority if 1 or more
| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)
// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.
| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)
| extend UEBA_Insights = pack_dictionary("TimeGenerated", TimeGenerated, "ActivityInsights", ActivityInsights, "UsersInsights", UsersInsights, "DevicesInsights", DevicesInsights)
| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by
UEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority
| extend UEBA_Info = pack_dictionary("UEBA_Insights", UEBA_Insights, "UEBA_ItemIds", UEBA_ItemIds, "UEBA_SourceRecordIds", UEBA_SourceRecordIds)
| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights
| join kind=inner ( 
  SigninsSummary
) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress
| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType
;
SigninsWithUEBA 
| join kind= leftanti (
   // filter out newly created user accounts from last 7 days
   AuditLogs
   | where TimeGenerated between(midtime..endtime)
   | where OperationName == "Add user"
   | summarize by NewUserId = tostring(TargetResources[0].id)
) on $left.UserId == $right.NewUserId
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Risky Sign-in with new MFA method

'Looks for a new MFA method added to an account that was preceded by medium or high risk
sign-in session for the same user within maximum 6h timeframe'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | bfacf634-c75e-4291-998c-ecbc0323d943 |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithNewMFAMethod.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let mfaMethodAdded=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Update user" 
| where TargetResources has "StrongAuthenticationPhoneAppDetail"
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| project MfaAddedTimestamp=TimeGenerated,AccountUpn,AccountObjectId;
let usersWithNewMFAMethod=mfaMethodAdded
| distinct AccountObjectId;
let hasusersWithNewMFAMethod = isnotempty(toscalar(usersWithNewMFAMethod));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasusersWithNewMFAMethod
| where UserId in (usersWithNewMFAMethod) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
mfaMethodAdded 
| join riskySignins on AccountObjectId 
| where  MfaAddedTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = MfaAddedTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Risky Sign-in with new MFA method

'Looks for a new MFA method added to an account that was preceded by medium or high risk
sign-in session for the same user within maximum 6h timeframe'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | bfacf634-c75e-4291-998c-ecbc0323d943 |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithNewMFAMethod.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let mfaMethodAdded=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Update user" 
| where TargetResources has "StrongAuthenticationPhoneAppDetail"
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| project MfaAddedTimestamp=TimeGenerated,AccountUpn,AccountObjectId;
let usersWithNewMFAMethod=mfaMethodAdded
| distinct AccountObjectId;
let hasusersWithNewMFAMethod = isnotempty(toscalar(usersWithNewMFAMethod));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasusersWithNewMFAMethod
| where UserId in (usersWithNewMFAMethod) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
mfaMethodAdded 
| join riskySignins on AccountObjectId 
| where  MfaAddedTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = MfaAddedTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Risky Sign-in with new MFA method

'Looks for a new MFA method added to an account that was preceded by medium or high risk
sign-in session for the same user within maximum 6h timeframe'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | bfacf634-c75e-4291-998c-ecbc0323d943 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithNewMFAMethod.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let mfaMethodAdded=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Update user" 
| where TargetResources has "StrongAuthenticationPhoneAppDetail"
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| project MfaAddedTimestamp=TimeGenerated,AccountUpn,AccountObjectId;
let usersWithNewMFAMethod=mfaMethodAdded
| distinct AccountObjectId;
let hasusersWithNewMFAMethod = isnotempty(toscalar(usersWithNewMFAMethod));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasusersWithNewMFAMethod
| where UserId in (usersWithNewMFAMethod) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
mfaMethodAdded 
| join riskySignins on AccountObjectId 
| where  MfaAddedTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = MfaAddedTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Risky Sign-in with new MFA method

'Looks for a new MFA method added to an account that was preceded by medium or high risk
sign-in session for the same user within maximum 6h timeframe'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | bfacf634-c75e-4291-998c-ecbc0323d943 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithNewMFAMethod.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timeDelta = 6h;
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let mfaMethodAdded=AuditLogs
| where TimeGenerated between (starttime .. endtime)
| where OperationName =~ "Update user" 
| where TargetResources has "StrongAuthenticationPhoneAppDetail"
| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)
| extend AccountObjectId = tostring(TargetResources[0].id)
| project MfaAddedTimestamp=TimeGenerated,AccountUpn,AccountObjectId;
let usersWithNewMFAMethod=mfaMethodAdded
| distinct AccountObjectId;
let hasusersWithNewMFAMethod = isnotempty(toscalar(usersWithNewMFAMethod));
let riskySignins=SigninLogs
| where TimeGenerated between ((starttime-timeDelta) .. endtime)
| where hasusersWithNewMFAMethod
| where UserId in (usersWithNewMFAMethod) 
| where RiskLevelDuringSignIn has_any ('medium', 'high')
| where AppDisplayName in~ ("Office 365 Exchange Online", "OfficeHome") 
| where isnotempty(Id) 
| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn 
| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;
mfaMethodAdded 
| join riskySignins on AccountObjectId 
| where  MfaAddedTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h 
| project-away AccountObjectId1
| extend timestamp = MfaAddedTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress

```

## Spike in failed sign-in events

'Identifies spikes in failed sign-in events based on the volume of failed sign-in events over time. Use to identify patterns of suspicious behavior such as unusually high failed sign-in attempts from certain users.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 51f4faf9-c3b1-4e9f-9c90-5d6afd191552 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SpikeInFailedSignInAttempts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let auditLookback = starttime - 14d;
let ts_data = (SigninLogs
| where TimeGenerated between (auditLookback..endtime)
| where ResultType != 0
| make-series count() on TimeGenerated step 1h by UserPrincipalName
| extend series_decompose(count_)
| extend NoLogons = count_);
let TimeSeriesAlerts=ts_data
  | extend (anomalies, score, baseline) = series_decompose_anomalies(count_, 1.5, -1, 'linefit',0, 'ctukey', 0.7)
  | mv-expand NoLogons to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
  | where anomalies > 0
  | project UserPrincipalName, TimeGenerated, NoLogons, baseline, anomalies, score;
TimeSeriesAlerts
  | join kind=inner (
  SigninLogs
  | where TimeGenerated between (auditLookback..endtime)
  | summarize ResultTypeCount=count(),ResultTypes=make_set(ResultType), Locations=make_set(Location), Apps=make_set(AppDisplayName), Ips=make_set( IPAddress) by UserPrincipalName, bin(TimeGenerated, 1h)
  ) on UserPrincipalName, TimeGenerated
  | summarize AnomolyTimes = make_set(TimeGenerated), Ips = make_set(Ips), Apps = make_set(Apps), sum(anomalies), Locations=make_set(Locations) by UserPrincipalName
  | sort by sum_anomalies desc
  | extend timestamp = tostring(AnomolyTimes[0]), AccountCustomEntity = UserPrincipalName

```

## Spike in failed sign-in events

'Identifies spikes in failed sign-in events based on the volume of failed sign-in events over time. Use to identify patterns of suspicious behavior such as unusually high failed sign-in attempts from certain users.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078.004|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 51f4faf9-c3b1-4e9f-9c90-5d6afd191552 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SpikeInFailedSignInAttempts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let auditLookback = starttime - 14d;
let ts_data = (SigninLogs
| where TimeGenerated between (auditLookback..endtime)
| where ResultType != 0
| make-series count() on TimeGenerated step 1h by UserPrincipalName
| extend series_decompose(count_)
| extend NoLogons = count_);
let TimeSeriesAlerts=ts_data
  | extend (anomalies, score, baseline) = series_decompose_anomalies(count_, 1.5, -1, 'linefit',0, 'ctukey', 0.7)
  | mv-expand NoLogons to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
  | where anomalies > 0
  | project UserPrincipalName, TimeGenerated, NoLogons, baseline, anomalies, score;
TimeSeriesAlerts
  | join kind=inner (
  SigninLogs
  | where TimeGenerated between (auditLookback..endtime)
  | summarize ResultTypeCount=count(),ResultTypes=make_set(ResultType), Locations=make_set(Location), Apps=make_set(AppDisplayName), Ips=make_set( IPAddress) by UserPrincipalName, bin(TimeGenerated, 1h)
  ) on UserPrincipalName, TimeGenerated
  | summarize AnomolyTimes = make_set(TimeGenerated), Ips = make_set(Ips), Apps = make_set(Apps), sum(anomalies), Locations=make_set(Locations) by UserPrincipalName
  | sort by sum_anomalies desc
  | extend timestamp = tostring(AnomolyTimes[0]), AccountCustomEntity = UserPrincipalName

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1098|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1098|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1098|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempts using Legacy Auth

'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the
environment. Because conditional access policies are not evaluated when legacy authentication is used,
legacy authentication can be used to circumvent all Azure Conditional Access policies.'

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | T1098|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | b7918a0a-c6fe-4b6d-9111-b0b0c477f1a8 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let legacy_auth_protocols = dynamic(["Authenticated SMTP", "AutoDiscover", "Exchange ActiveSync", "Exchange Online PowerShell", "Exchange Web Services", "IMAP4", "MAPI Over HTTP", "Outlook Anywhere (RPC over HTTP)", "Outlook Service", "POP3", "Reporting Web Services", "Other clients"]);
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(lookback)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,"Unknown" ,ClientAppUsed)
| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), "Yes", "No")
| where isLegacyAuth=="Yes";
legacyAuthentications
| where TimeGenerated >= starttime
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications
   | where TimeGenerated between(ago(lookback)..starttime)
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/",
tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempt by Blocked MFA user

'An account could be blocked if there are too many failed authentication attempts in a row. This hunting query identifies if a MFA user account that is set to blocked tries to login to Azure AD.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 75fd68a2-9ed4-4a1c-8bd7-18efe4c99081 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/MFAUserBlocked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 7d;
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let MFABlocked = SigninLogs
| where TimeGenerated between(starttime..endtime)
| where ResultType != "0"
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), Status = strcat(ResultType, ": ", ResultDescription)
| where StatusDetails =~ "MFA denied; user is blocked"
| extend Unresolved = iff(Identity matches regex isGUID, true, false);
// Lookup up resolved identities from last 7 days
let identityLookup = SigninLogs
| where TimeGenerated between(lookback..starttime)
| where not(Identity matches regex isGUID)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// Join resolved names to unresolved list from MFABlocked signins
let unresolvedNames = MFABlocked | where Unresolved == true | join kind= inner (
 identityLookup
) on UserId
| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName
| project-away lu_UserDisplayName, lu_UserPrincipalName;
// Join Signins that had resolved names with list of unresolved that now have a resolved name
let u_MFABlocked = MFABlocked | where Unresolved == false | union unresolvedNames;
u_MFABlocked
| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress),
  AttemptCount = count() by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation , CorrelationId
| mvexpand TimeGenerated, IPAddresses, Status
| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)
| project-away IPAddresses
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status,  IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Login attempt by Blocked MFA user

'An account could be blocked if there are too many failed authentication attempts in a row. This hunting query identifies if a MFA user account that is set to blocked tries to login to Azure AD.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1078|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 75fd68a2-9ed4-4a1c-8bd7-18efe4c99081 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/MFAUserBlocked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 7d;
let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
let MFABlocked = SigninLogs
| where TimeGenerated between(starttime..endtime)
| where ResultType != "0"
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), Status = strcat(ResultType, ": ", ResultDescription)
| where StatusDetails =~ "MFA denied; user is blocked"
| extend Unresolved = iff(Identity matches regex isGUID, true, false);
// Lookup up resolved identities from last 7 days
let identityLookup = SigninLogs
| where TimeGenerated between(lookback..starttime)
| where not(Identity matches regex isGUID)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// Join resolved names to unresolved list from MFABlocked signins
let unresolvedNames = MFABlocked | where Unresolved == true | join kind= inner (
 identityLookup
) on UserId
| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName
| project-away lu_UserDisplayName, lu_UserPrincipalName;
// Join Signins that had resolved names with list of unresolved that now have a resolved name
let u_MFABlocked = MFABlocked | where Unresolved == false | union unresolvedNames;
u_MFABlocked
| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress),
  AttemptCount = count() by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation , CorrelationId
| mvexpand TimeGenerated, IPAddresses, Status
| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)
| project-away IPAddresses
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status,  IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress

```

## Preview - TI map File entity to OfficeActivity Event

'Identifies a match in OfficeActivity Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Office 365|
|DetectionType | Hunting |
|ConnectorId | Office365 |
|DetectionId | 410da56d-4a63-4d22-b68c-9fb1a303be6d |
|DataTypes | OfficeActivity |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_OfficeActivity.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  OfficeActivity
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(SourceFileName)
  | extend OfficeActivity_TimeGenerated = TimeGenerated
)
on $left.FileName == $right.SourceFileName
| where OfficeActivity_TimeGenerated < ExpirationDateTime
| summarize OfficeActivity_TimeGenerated = arg_max(OfficeActivity_TimeGenerated, *) by IndicatorId, SourceFileName
| project OfficeActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, FileName, UserId, ClientIP, OfficeObjectId
| extend timestamp = OfficeActivity_TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Url

```

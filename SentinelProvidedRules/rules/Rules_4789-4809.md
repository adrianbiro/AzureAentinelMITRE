# Rules: 4789-4809

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | macOS|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Office 365|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligence |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | macOS|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | AWS|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Preview - TI map File entity to VMConnection Event

'Identifies a match in VMConnection Event data from any FileName IOC from TI.
As File name matches can create noise, this is best as hunting query'

|Name | Value |
| --- | --- |
|Tactic | Impact|
|TechniqueId | |
|Platform | Office 365|
|DetectionType | Hunting |
|ConnectorId | ThreatIntelligenceTaxii |
|DetectionId | 172a321b-c46b-4508-87c6-e2691c778107 |
|DataTypes | ThreatIntelligenceIndicator |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ioc_lookBack = 14d;
ThreatIntelligenceIndicator
| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()
| where Active == true
| where isnotempty(FileName)
| extend TI_ProcessEntity = tostring(split(FileName, ".")[-2])
// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated
| join kind=innerunique (
  VMConnection 
  | where TimeGenerated between(starttime..endtime)
  | where isnotempty(ProcessName)
  | extend VMConnection_TimeGenerated = TimeGenerated
)
on $left.TI_ProcessEntity == $right.ProcessName
| where VMConnection_TimeGenerated < ExpirationDateTime
| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName
| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,
FileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol
| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url

```

## Abnormally long DNS URI queries

'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1568|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | a0954a17-cc66-4d47-9651-8bf524bbdcc8 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ".")[-2]),".", tostring(split(Computer, ".")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents
| where SubType =~ "LookupQuery"
| where ipv4_is_match("127.0.0.1", ClientIP) == False 
| where Name !endswith ".local" and Name !startswith "_" and Name !startswith "#"
| where Name !contains "::1"
| where Name !has "cnr.io" and Name !has "kr0.io" and Name !has "arcticwolf.net" and Name !has "webcfs00.com" and Name !has "barracudabrts.com"and Name !has "trendmicro.com" 
and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" 
and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" and Name !has "ipass.com" and Name !has "wpad"
and Name !has "cnr.io" and Name !has "trendmicro.com" and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" 
and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" 
and Name !has "ipass.com"
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ".")) <= 2, Name,
tostring(split(Name, ".")[-2]) == "corp", strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-1])) == 2, strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-2])) != "corp", strcat(tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name

```

## Abnormally long DNS URI queries

'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1568|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | a0954a17-cc66-4d47-9651-8bf524bbdcc8 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ".")[-2]),".", tostring(split(Computer, ".")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents
| where SubType =~ "LookupQuery"
| where ipv4_is_match("127.0.0.1", ClientIP) == False 
| where Name !endswith ".local" and Name !startswith "_" and Name !startswith "#"
| where Name !contains "::1"
| where Name !has "cnr.io" and Name !has "kr0.io" and Name !has "arcticwolf.net" and Name !has "webcfs00.com" and Name !has "barracudabrts.com"and Name !has "trendmicro.com" 
and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" 
and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" and Name !has "ipass.com" and Name !has "wpad"
and Name !has "cnr.io" and Name !has "trendmicro.com" and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" 
and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" 
and Name !has "ipass.com"
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ".")) <= 2, Name,
tostring(split(Name, ".")[-2]) == "corp", strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-1])) == 2, strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-2])) != "corp", strcat(tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name

```

## Abnormally long DNS URI queries

'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1568|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | a0954a17-cc66-4d47-9651-8bf524bbdcc8 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ".")[-2]),".", tostring(split(Computer, ".")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents
| where SubType =~ "LookupQuery"
| where ipv4_is_match("127.0.0.1", ClientIP) == False 
| where Name !endswith ".local" and Name !startswith "_" and Name !startswith "#"
| where Name !contains "::1"
| where Name !has "cnr.io" and Name !has "kr0.io" and Name !has "arcticwolf.net" and Name !has "webcfs00.com" and Name !has "barracudabrts.com"and Name !has "trendmicro.com" 
and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" 
and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" and Name !has "ipass.com" and Name !has "wpad"
and Name !has "cnr.io" and Name !has "trendmicro.com" and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" 
and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" 
and Name !has "ipass.com"
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ".")) <= 2, Name,
tostring(split(Name, ".")[-2]) == "corp", strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-1])) == 2, strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-2])) != "corp", strcat(tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name

```

## Abnormally long DNS URI queries

'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1008|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | a0954a17-cc66-4d47-9651-8bf524bbdcc8 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ".")[-2]),".", tostring(split(Computer, ".")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents
| where SubType =~ "LookupQuery"
| where ipv4_is_match("127.0.0.1", ClientIP) == False 
| where Name !endswith ".local" and Name !startswith "_" and Name !startswith "#"
| where Name !contains "::1"
| where Name !has "cnr.io" and Name !has "kr0.io" and Name !has "arcticwolf.net" and Name !has "webcfs00.com" and Name !has "barracudabrts.com"and Name !has "trendmicro.com" 
and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" 
and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" and Name !has "ipass.com" and Name !has "wpad"
and Name !has "cnr.io" and Name !has "trendmicro.com" and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" 
and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" 
and Name !has "ipass.com"
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ".")) <= 2, Name,
tostring(split(Name, ".")[-2]) == "corp", strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-1])) == 2, strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-2])) != "corp", strcat(tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name

```

## Abnormally long DNS URI queries

'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1008|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | a0954a17-cc66-4d47-9651-8bf524bbdcc8 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ".")[-2]),".", tostring(split(Computer, ".")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents
| where SubType =~ "LookupQuery"
| where ipv4_is_match("127.0.0.1", ClientIP) == False 
| where Name !endswith ".local" and Name !startswith "_" and Name !startswith "#"
| where Name !contains "::1"
| where Name !has "cnr.io" and Name !has "kr0.io" and Name !has "arcticwolf.net" and Name !has "webcfs00.com" and Name !has "barracudabrts.com"and Name !has "trendmicro.com" 
and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" 
and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" and Name !has "ipass.com" and Name !has "wpad"
and Name !has "cnr.io" and Name !has "trendmicro.com" and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" 
and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" 
and Name !has "ipass.com"
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ".")) <= 2, Name,
tostring(split(Name, ".")[-2]) == "corp", strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-1])) == 2, strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-2])) != "corp", strcat(tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name

```

## Abnormally long DNS URI queries

'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used 
for data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks 
for Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names
this can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your
environment.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1008|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | a0954a17-cc66-4d47-9651-8bf524bbdcc8 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/DnsEvents/DNS_LongURILookup.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

// Setting URI length threshold count, shorter URI's may cause noise, change as needed
let uriThreshold = 150;
let LocalDomains = 
(
DnsEvents
| summarize count() by Computer 
| extend SubDomain = tolower(strcat(tostring(split(Computer, ".")[-2]),".", tostring(split(Computer, ".")[-1])))
| distinct SubDomain
);
let DomainLookups =
(
DnsEvents
| where SubType =~ "LookupQuery"
| where ipv4_is_match("127.0.0.1", ClientIP) == False 
| where Name !endswith ".local" and Name !startswith "_" and Name !startswith "#"
| where Name !contains "::1"
| where Name !has "cnr.io" and Name !has "kr0.io" and Name !has "arcticwolf.net" and Name !has "webcfs00.com" and Name !has "barracudabrts.com"and Name !has "trendmicro.com" 
and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" 
and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" and Name !has "ipass.com" and Name !has "wpad"
and Name !has "cnr.io" and Name !has "trendmicro.com" and Name !has "sophosxl.net" and Name !has "spotify.com" and Name !has "e5.sk" and Name !has "mcafee.com" 
and Name !has "opendns.com"  and Name !has "spameatingmonkey.net" and Name !has "_ldap" and Name !has "_kerberos" and Name !has "modsecurity.org" and Name !has "fdmarc.net" 
and Name !has "ipass.com"
| extend Name = tolower(Name), Urilength = strlen(Name) 
| where Urilength >= uriThreshold
| extend SubDomain = case(
isempty(Name), Name,
array_length(split(Name, ".")) <= 2, Name,
tostring(split(Name, ".")[-2]) == "corp", strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-1])) == 2, strcat(tostring(split(Name, ".")[-3]),".",tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
strlen(tostring(split(Name, ".")[-2])) != "corp", strcat(tostring(split(Name, ".")[-2]),".", tostring(split(Name, ".")[-1])),
Name))
;
DomainLookups
| join kind= leftanti (
    LocalDomains
) on SubDomain 
| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength
| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name

```

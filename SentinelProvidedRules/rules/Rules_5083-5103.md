# Rules: 5083-5103

## Risky base64 encoded command in URL

'This hunting query will detect risky base64 encoded commands are seen in web requests. Some threat actors transmit base64 commands from the target host
back to the C2 servers so they know which command has been executed. This query also reguarly illumniates base64 encoded webshells being injected.
The limitation of this query is that base64 is case sensitive, so different case versions of each command need generating for full coverage. This query
computes base64 permutations for each command, resulting in 3 possible permutations depending on padding.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | c46eeb45-c324-4a84-9df1-248c6d1507bb |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/RiskyCommandB64EncodedInUrl.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let mapping = datatable (CommandFound:string, match_list:dynamic) [
"whoami", dynamic(['d2hvYW1p', 'dob2Fta', '3aG9hbW']),
"net share", dynamic(['bmV0IHNoYXJl', '5ldCBzaGFyZ', 'uZXQgc2hhcm']),
"net use", dynamic(['bmV0IHVzZ', '5ldCB1c2', 'uZXQgdXNl']),
"net view", dynamic(['bmV0IHZpZX', '5ldCB2aWV3', 'uZXQgdmlld']),
"ipconfig", dynamic(['aXBjb25maWc', 'lwY29uZmln', 'pcGNvbmZpZ']),
"net sh", dynamic(['bmV0c2gg', '5ldHNoI', 'uZXRzaC']),
"schtasks", dynamic(['2NodGFza3', 'NjaHRhc2tz', 'zY2h0YXNrc']),
"Invoke- ", dynamic(['SW52b2tlL', 'ludm9rZS', 'JbnZva2Ut']),
];
let riskyCommandRegex = @"(d2hvYW1p|dob2Fta|3aG9hbW|bmV0IHNoYXJl|5ldCBzaGFyZ|uZXQgc2hhcm|bmV0IHVzZ|5ldCB1c2|uZXQgdXNl|bmV0IHZpZX|5ldCB2aWV3|uZXQgdmlld|aXBjb25maWc|lwY29uZmln|pcGNvbmZpZ|bmV0c2gg|5ldHNoI|uZXRzaC|2NodGFza3|NjaHRhc2tz|zY2h0YXNrc|SW52b2tlL|ludm9rZS|JbnZva2Ut)";
CommonSecurityLog
| where TimeGenerated > ago(3d)
| where RequestURL matches regex riskyCommandRegex
| extend B64MatchData = extract_all(riskyCommandRegex, RequestURL)
| where isnotempty(B64MatchData)
| mv-expand B64MatchData to typeof(string)
| join kind=leftouter ( 
    mapping
    | mv-expand match_list to typeof(string)
) on $left.B64MatchData == $right.match_list
| project TimeGenerated, B64MatchData, CommandFound, RequestURL, RequestMethod, DestinationHostName, DestinationIP, SourceIP, DeviceVendor, DeviceProduct, Activity
| extend timestamp = TimeGenerated, DomainCustomEntity = DestinationHostName, IPCustomEntity = DestinationIP

```

## Risky base64 encoded command in URL

'This hunting query will detect risky base64 encoded commands are seen in web requests. Some threat actors transmit base64 commands from the target host
back to the C2 servers so they know which command has been executed. This query also reguarly illumniates base64 encoded webshells being injected.
The limitation of this query is that base64 is case sensitive, so different case versions of each command need generating for full coverage. This query
computes base64 permutations for each command, resulting in 3 possible permutations depending on padding.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | c46eeb45-c324-4a84-9df1-248c6d1507bb |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/RiskyCommandB64EncodedInUrl.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let mapping = datatable (CommandFound:string, match_list:dynamic) [
"whoami", dynamic(['d2hvYW1p', 'dob2Fta', '3aG9hbW']),
"net share", dynamic(['bmV0IHNoYXJl', '5ldCBzaGFyZ', 'uZXQgc2hhcm']),
"net use", dynamic(['bmV0IHVzZ', '5ldCB1c2', 'uZXQgdXNl']),
"net view", dynamic(['bmV0IHZpZX', '5ldCB2aWV3', 'uZXQgdmlld']),
"ipconfig", dynamic(['aXBjb25maWc', 'lwY29uZmln', 'pcGNvbmZpZ']),
"net sh", dynamic(['bmV0c2gg', '5ldHNoI', 'uZXRzaC']),
"schtasks", dynamic(['2NodGFza3', 'NjaHRhc2tz', 'zY2h0YXNrc']),
"Invoke- ", dynamic(['SW52b2tlL', 'ludm9rZS', 'JbnZva2Ut']),
];
let riskyCommandRegex = @"(d2hvYW1p|dob2Fta|3aG9hbW|bmV0IHNoYXJl|5ldCBzaGFyZ|uZXQgc2hhcm|bmV0IHVzZ|5ldCB1c2|uZXQgdXNl|bmV0IHZpZX|5ldCB2aWV3|uZXQgdmlld|aXBjb25maWc|lwY29uZmln|pcGNvbmZpZ|bmV0c2gg|5ldHNoI|uZXRzaC|2NodGFza3|NjaHRhc2tz|zY2h0YXNrc|SW52b2tlL|ludm9rZS|JbnZva2Ut)";
CommonSecurityLog
| where TimeGenerated > ago(3d)
| where RequestURL matches regex riskyCommandRegex
| extend B64MatchData = extract_all(riskyCommandRegex, RequestURL)
| where isnotempty(B64MatchData)
| mv-expand B64MatchData to typeof(string)
| join kind=leftouter ( 
    mapping
    | mv-expand match_list to typeof(string)
) on $left.B64MatchData == $right.match_list
| project TimeGenerated, B64MatchData, CommandFound, RequestURL, RequestMethod, DestinationHostName, DestinationIP, SourceIP, DeviceVendor, DeviceProduct, Activity
| extend timestamp = TimeGenerated, DomainCustomEntity = DestinationHostName, IPCustomEntity = DestinationIP

```

## Risky base64 encoded command in URL

'This hunting query will detect risky base64 encoded commands are seen in web requests. Some threat actors transmit base64 commands from the target host
back to the C2 servers so they know which command has been executed. This query also reguarly illumniates base64 encoded webshells being injected.
The limitation of this query is that base64 is case sensitive, so different case versions of each command need generating for full coverage. This query
computes base64 permutations for each command, resulting in 3 possible permutations depending on padding.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | c46eeb45-c324-4a84-9df1-248c6d1507bb |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/RiskyCommandB64EncodedInUrl.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let mapping = datatable (CommandFound:string, match_list:dynamic) [
"whoami", dynamic(['d2hvYW1p', 'dob2Fta', '3aG9hbW']),
"net share", dynamic(['bmV0IHNoYXJl', '5ldCBzaGFyZ', 'uZXQgc2hhcm']),
"net use", dynamic(['bmV0IHVzZ', '5ldCB1c2', 'uZXQgdXNl']),
"net view", dynamic(['bmV0IHZpZX', '5ldCB2aWV3', 'uZXQgdmlld']),
"ipconfig", dynamic(['aXBjb25maWc', 'lwY29uZmln', 'pcGNvbmZpZ']),
"net sh", dynamic(['bmV0c2gg', '5ldHNoI', 'uZXRzaC']),
"schtasks", dynamic(['2NodGFza3', 'NjaHRhc2tz', 'zY2h0YXNrc']),
"Invoke- ", dynamic(['SW52b2tlL', 'ludm9rZS', 'JbnZva2Ut']),
];
let riskyCommandRegex = @"(d2hvYW1p|dob2Fta|3aG9hbW|bmV0IHNoYXJl|5ldCBzaGFyZ|uZXQgc2hhcm|bmV0IHVzZ|5ldCB1c2|uZXQgdXNl|bmV0IHZpZX|5ldCB2aWV3|uZXQgdmlld|aXBjb25maWc|lwY29uZmln|pcGNvbmZpZ|bmV0c2gg|5ldHNoI|uZXRzaC|2NodGFza3|NjaHRhc2tz|zY2h0YXNrc|SW52b2tlL|ludm9rZS|JbnZva2Ut)";
CommonSecurityLog
| where TimeGenerated > ago(3d)
| where RequestURL matches regex riskyCommandRegex
| extend B64MatchData = extract_all(riskyCommandRegex, RequestURL)
| where isnotempty(B64MatchData)
| mv-expand B64MatchData to typeof(string)
| join kind=leftouter ( 
    mapping
    | mv-expand match_list to typeof(string)
) on $left.B64MatchData == $right.match_list
| project TimeGenerated, B64MatchData, CommandFound, RequestURL, RequestMethod, DestinationHostName, DestinationIP, SourceIP, DeviceVendor, DeviceProduct, Activity
| extend timestamp = TimeGenerated, DomainCustomEntity = DestinationHostName, IPCustomEntity = DestinationIP

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | Zscaler |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | Zscaler |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | Zscaler |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | Fortinet |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | Fortinet |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | Fortinet |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | CheckPoint |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | CheckPoint |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | CheckPoint |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Base64 encoded IPv4 address in request url

'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection
of an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract
the ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071.001|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 39156a1d-c9e3-439e-967b-be7dcba918d9 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let ipv4_plaintext_extraction_regex = @"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})";
let ipv4_encoded_identification_regex = @"\=([a-zA-Z0-9\/\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\/\+]{2,4}){3}[a-zA-Z0-9\/\+\=]*)";
let ipv4_decoded_hex_extract = @"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})";
CommonSecurityLog
| where TimeGenerated between(starttime .. endtime)
| where isnotempty(RequestURL)
// Identify requests with encoded IPv4 addresses
| where RequestURL matches regex ipv4_encoded_identification_regex
| project TimeGenerated, RequestURL
// Extract IP candidates in their base64 encoded format, significantly reducing the dataset
| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)
// We could have more than one candidate, expand them out
| mv-expand extracted_encoded_ip_candidate to typeof(string)
| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate
// Pad if we need to
| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, "="))
// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first
| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))
// Extract the IP candidates from the array
| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)
// Expand, it's still possible that we might have more than 1 IP
| mv-expand hex_extracted
// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.
| extend hex_extracted = trim_end(",", tostring(hex_extracted))
| extend hex_extracted = strcat("[",hex_extracted,"]")
| extend hex_extracted = todynamic(hex_extracted)
| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)
// Convert the array back into a string
| extend decoded_ip_candidate = make_string(hex_extracted)
| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End
// Now the IP candidates will be in plaintext, extract the IPs using a regex
| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)
// If it's not an IP, throw it out
| where isnotnull(ipmatch)
| mv-expand ipmatch to typeof(string)
| extend timestamp = Start, IPCustomEntity = ipmatch

```

## Palo Alto - high-risk ports

'Identifies network connections whose ports are frequent targets of attacks and should not cross network boundaries or reach untrusted public networks.
Consider updating the firewall policies to block the connections.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 0a57accf-3548-4e38-a861-99687c958f59 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/PaloAlto-HighRiskPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let HighRiskPorts = datatable (Port:int, Protocol:string, RiskType:string, RiskDescription:string)[
13,"udp","3rd Party Attacks","Daytime protocol used in reflection/amplification attacks",
17,"udp","3rd Party Attacks","QOTD protocol, reflection/amplification attacks",
19,"udp","3rd Party Attacks","Chargen protocol, reflection/amplification attacks",
20,"tcp","Unencrypted","Unencrypted FTP Traffic",
21,"tcp","Unencrypted","Unencrypted FTP Traffic",
22,"tcp","Management","SSH, brute force attacks common",
23,"tcp","Management","Telnet, allows unauthenticated and/or unencrypted",
53,"udp","3rd Party Attacks","DNS, reflection/amplification attacks",
69,"udp","Management","TFTP, allows unauthenticated and/or unencrypted",
111,"udp","Management","RPC, unencrypted authentication allowed",
111,"tcp","Management","RPC, unencrypted authentication allowed",
119,"tcp","Unsecure","NNTP, unencrypted authentication",
123,"udp","3rd Party Attacks","Network Time Protocol, reflection/amplification attacks",
135,"tcp","Management","End Point Mapper, multiple remote management srvcs",
135,"udp","Management","End Point Mapper, multiple remote management srvcs",
137,"tcp","Hacker Recon","Netbios Name Service",
137,"udp","Hacker Recon","Netbios Name Service",
138,"tcp","Hacker Recon","Netbios Datagram Service",
138,"udp","Hacker Recon","Netbios Datagram Service",
139,"tcp","Hacker Recon","Netbios Session Service",
161,"tcp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
161,"udp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
162,"tcp","Unsecure","SNMP Trap, unsecure / no authentication",
162,"udp","Unsecure","SNMP Trap, unsecure / no authentication",
389,"tcp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
389,"udp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
443,"udp","3rd Party Attacks","UDP Reflection / Amplification attacks",
445,"tcp","Unsecure","SMB - well known attack vector",
512,"tcp","Management","Rexec on Linux, remote commands w/o encrypt auth",
514,"tcp","Management","Remote Shell, remote commands w/o auth or encrypt",
593,"tcp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
593,"udp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
636,"tcp","Hacker Recon","Lightweight Directory Access Protocol",
873,"tcp","Management","Rsync, unencrypted file transfer",
1433,"tcp","Data Access/Mgmt","MS SQL Management & Data Access",
1434,"udp","Data Access/Mgmt","MS SQL Monitor Port",
1900,"udp","Hacker Recon/3rd Party Attacks","Simple Service Discovery Protocol, unencrypted",
2049,"tcp","Unsecure","Network File System",
2049,"udp","Unsecure","Network File System",
2301,"tcp","Hacker Recon","Compaq Management Service, no recent incidents",
2381,"tcp","Management","Compaq Management Service, no recent incidents",
3268,"tcp","Hacker Recon","Microsoft Global Catalog LDAP",
3306,"tcp","Data Access/Mgmt","MySQL Database Management Port",
3389,"tcp","Management/3rd Party Attacks","RDP, Common brute force attack port",
3389,"udp","Management/3rd Party Attacks","RDP, Common brute force attack port",
4333,"tcp","Data Access/Mgmt","MSql",
5353,"udp","3rd Party Attacks","mDNS",
5432,"tcp","Data Access/Mgmt","PostgresSQL Database Management",
5800,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5900,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5985,"tcp","Management","Windows Powershell",
5986,"tcp","Management","Windows Powershell",
6379,"tcp","Data Access/Mgmt","Redis",
7000,"tcp","Data Access/Mgmt","Cassandra",
7001,"tcp","Data Access/Mgmt","Cassandra",
7199,"tcp","Data Access/Mgmt","Cassandra",
9042,"tcp","Data Access/Mgmt","Cassandra",
9160,"tcp","Data Access/Mgmt","Cassandra",
9200,"tcp","Data Access/Mgmt","Elastic Search",
9300,"tcp","Data Access/Mgmt","Elastic Search",
9987,"udp","3rd Party Attack","DSM/SCM Target Interface",
11211,"udp","Unencrypted","Memcached",
16379,"tcp","Data Access/Mgmt","Redis",
26379,"tcp","Data Access/Mgmt","Redis",
27017,"tcp","Data Access/Mgmt","MongoDB",
];
HighRiskPorts
| join kind=inner (
  CommonSecurityLog
  | where DeviceVendor == "Palo Alto Networks" and Activity == "TRAFFIC" and DeviceAction != "deny"
  | where SentBytes > 0 and ReceivedBytes > 0
  //Remove private IP communation from DestinationIP
  | extend result = ipv4_is_private(DestinationIP) 
  | where result == 0
  | summarize
      Count = count(),
      StartTime = min(TimeGenerated),
      EndTime = max(TimeGenerated)
      by 
      DeviceName,
      SourceIP,
      DestinationIP,
      DestinationPort,
      Protocol
) on $left.Port == $right.DestinationPort and $left.Protocol == $right.Protocol
| project-away Protocol1, Port
| order by DeviceName asc, SourceIP asc, DestinationIP asc, DestinationPort asc
| extend timestamp = StartTime, IPCustomEntity = SourceIP

```

## Palo Alto - high-risk ports

'Identifies network connections whose ports are frequent targets of attacks and should not cross network boundaries or reach untrusted public networks.
Consider updating the firewall policies to block the connections.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 0a57accf-3548-4e38-a861-99687c958f59 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/PaloAlto-HighRiskPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let HighRiskPorts = datatable (Port:int, Protocol:string, RiskType:string, RiskDescription:string)[
13,"udp","3rd Party Attacks","Daytime protocol used in reflection/amplification attacks",
17,"udp","3rd Party Attacks","QOTD protocol, reflection/amplification attacks",
19,"udp","3rd Party Attacks","Chargen protocol, reflection/amplification attacks",
20,"tcp","Unencrypted","Unencrypted FTP Traffic",
21,"tcp","Unencrypted","Unencrypted FTP Traffic",
22,"tcp","Management","SSH, brute force attacks common",
23,"tcp","Management","Telnet, allows unauthenticated and/or unencrypted",
53,"udp","3rd Party Attacks","DNS, reflection/amplification attacks",
69,"udp","Management","TFTP, allows unauthenticated and/or unencrypted",
111,"udp","Management","RPC, unencrypted authentication allowed",
111,"tcp","Management","RPC, unencrypted authentication allowed",
119,"tcp","Unsecure","NNTP, unencrypted authentication",
123,"udp","3rd Party Attacks","Network Time Protocol, reflection/amplification attacks",
135,"tcp","Management","End Point Mapper, multiple remote management srvcs",
135,"udp","Management","End Point Mapper, multiple remote management srvcs",
137,"tcp","Hacker Recon","Netbios Name Service",
137,"udp","Hacker Recon","Netbios Name Service",
138,"tcp","Hacker Recon","Netbios Datagram Service",
138,"udp","Hacker Recon","Netbios Datagram Service",
139,"tcp","Hacker Recon","Netbios Session Service",
161,"tcp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
161,"udp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
162,"tcp","Unsecure","SNMP Trap, unsecure / no authentication",
162,"udp","Unsecure","SNMP Trap, unsecure / no authentication",
389,"tcp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
389,"udp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
443,"udp","3rd Party Attacks","UDP Reflection / Amplification attacks",
445,"tcp","Unsecure","SMB - well known attack vector",
512,"tcp","Management","Rexec on Linux, remote commands w/o encrypt auth",
514,"tcp","Management","Remote Shell, remote commands w/o auth or encrypt",
593,"tcp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
593,"udp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
636,"tcp","Hacker Recon","Lightweight Directory Access Protocol",
873,"tcp","Management","Rsync, unencrypted file transfer",
1433,"tcp","Data Access/Mgmt","MS SQL Management & Data Access",
1434,"udp","Data Access/Mgmt","MS SQL Monitor Port",
1900,"udp","Hacker Recon/3rd Party Attacks","Simple Service Discovery Protocol, unencrypted",
2049,"tcp","Unsecure","Network File System",
2049,"udp","Unsecure","Network File System",
2301,"tcp","Hacker Recon","Compaq Management Service, no recent incidents",
2381,"tcp","Management","Compaq Management Service, no recent incidents",
3268,"tcp","Hacker Recon","Microsoft Global Catalog LDAP",
3306,"tcp","Data Access/Mgmt","MySQL Database Management Port",
3389,"tcp","Management/3rd Party Attacks","RDP, Common brute force attack port",
3389,"udp","Management/3rd Party Attacks","RDP, Common brute force attack port",
4333,"tcp","Data Access/Mgmt","MSql",
5353,"udp","3rd Party Attacks","mDNS",
5432,"tcp","Data Access/Mgmt","PostgresSQL Database Management",
5800,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5900,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5985,"tcp","Management","Windows Powershell",
5986,"tcp","Management","Windows Powershell",
6379,"tcp","Data Access/Mgmt","Redis",
7000,"tcp","Data Access/Mgmt","Cassandra",
7001,"tcp","Data Access/Mgmt","Cassandra",
7199,"tcp","Data Access/Mgmt","Cassandra",
9042,"tcp","Data Access/Mgmt","Cassandra",
9160,"tcp","Data Access/Mgmt","Cassandra",
9200,"tcp","Data Access/Mgmt","Elastic Search",
9300,"tcp","Data Access/Mgmt","Elastic Search",
9987,"udp","3rd Party Attack","DSM/SCM Target Interface",
11211,"udp","Unencrypted","Memcached",
16379,"tcp","Data Access/Mgmt","Redis",
26379,"tcp","Data Access/Mgmt","Redis",
27017,"tcp","Data Access/Mgmt","MongoDB",
];
HighRiskPorts
| join kind=inner (
  CommonSecurityLog
  | where DeviceVendor == "Palo Alto Networks" and Activity == "TRAFFIC" and DeviceAction != "deny"
  | where SentBytes > 0 and ReceivedBytes > 0
  //Remove private IP communation from DestinationIP
  | extend result = ipv4_is_private(DestinationIP) 
  | where result == 0
  | summarize
      Count = count(),
      StartTime = min(TimeGenerated),
      EndTime = max(TimeGenerated)
      by 
      DeviceName,
      SourceIP,
      DestinationIP,
      DestinationPort,
      Protocol
) on $left.Port == $right.DestinationPort and $left.Protocol == $right.Protocol
| project-away Protocol1, Port
| order by DeviceName asc, SourceIP asc, DestinationIP asc, DestinationPort asc
| extend timestamp = StartTime, IPCustomEntity = SourceIP

```

## Palo Alto - high-risk ports

'Identifies network connections whose ports are frequent targets of attacks and should not cross network boundaries or reach untrusted public networks.
Consider updating the firewall policies to block the connections.'

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | |
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 0a57accf-3548-4e38-a861-99687c958f59 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/PaloAlto-HighRiskPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let HighRiskPorts = datatable (Port:int, Protocol:string, RiskType:string, RiskDescription:string)[
13,"udp","3rd Party Attacks","Daytime protocol used in reflection/amplification attacks",
17,"udp","3rd Party Attacks","QOTD protocol, reflection/amplification attacks",
19,"udp","3rd Party Attacks","Chargen protocol, reflection/amplification attacks",
20,"tcp","Unencrypted","Unencrypted FTP Traffic",
21,"tcp","Unencrypted","Unencrypted FTP Traffic",
22,"tcp","Management","SSH, brute force attacks common",
23,"tcp","Management","Telnet, allows unauthenticated and/or unencrypted",
53,"udp","3rd Party Attacks","DNS, reflection/amplification attacks",
69,"udp","Management","TFTP, allows unauthenticated and/or unencrypted",
111,"udp","Management","RPC, unencrypted authentication allowed",
111,"tcp","Management","RPC, unencrypted authentication allowed",
119,"tcp","Unsecure","NNTP, unencrypted authentication",
123,"udp","3rd Party Attacks","Network Time Protocol, reflection/amplification attacks",
135,"tcp","Management","End Point Mapper, multiple remote management srvcs",
135,"udp","Management","End Point Mapper, multiple remote management srvcs",
137,"tcp","Hacker Recon","Netbios Name Service",
137,"udp","Hacker Recon","Netbios Name Service",
138,"tcp","Hacker Recon","Netbios Datagram Service",
138,"udp","Hacker Recon","Netbios Datagram Service",
139,"tcp","Hacker Recon","Netbios Session Service",
161,"tcp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
161,"udp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
162,"tcp","Unsecure","SNMP Trap, unsecure / no authentication",
162,"udp","Unsecure","SNMP Trap, unsecure / no authentication",
389,"tcp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
389,"udp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
443,"udp","3rd Party Attacks","UDP Reflection / Amplification attacks",
445,"tcp","Unsecure","SMB - well known attack vector",
512,"tcp","Management","Rexec on Linux, remote commands w/o encrypt auth",
514,"tcp","Management","Remote Shell, remote commands w/o auth or encrypt",
593,"tcp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
593,"udp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
636,"tcp","Hacker Recon","Lightweight Directory Access Protocol",
873,"tcp","Management","Rsync, unencrypted file transfer",
1433,"tcp","Data Access/Mgmt","MS SQL Management & Data Access",
1434,"udp","Data Access/Mgmt","MS SQL Monitor Port",
1900,"udp","Hacker Recon/3rd Party Attacks","Simple Service Discovery Protocol, unencrypted",
2049,"tcp","Unsecure","Network File System",
2049,"udp","Unsecure","Network File System",
2301,"tcp","Hacker Recon","Compaq Management Service, no recent incidents",
2381,"tcp","Management","Compaq Management Service, no recent incidents",
3268,"tcp","Hacker Recon","Microsoft Global Catalog LDAP",
3306,"tcp","Data Access/Mgmt","MySQL Database Management Port",
3389,"tcp","Management/3rd Party Attacks","RDP, Common brute force attack port",
3389,"udp","Management/3rd Party Attacks","RDP, Common brute force attack port",
4333,"tcp","Data Access/Mgmt","MSql",
5353,"udp","3rd Party Attacks","mDNS",
5432,"tcp","Data Access/Mgmt","PostgresSQL Database Management",
5800,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5900,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5985,"tcp","Management","Windows Powershell",
5986,"tcp","Management","Windows Powershell",
6379,"tcp","Data Access/Mgmt","Redis",
7000,"tcp","Data Access/Mgmt","Cassandra",
7001,"tcp","Data Access/Mgmt","Cassandra",
7199,"tcp","Data Access/Mgmt","Cassandra",
9042,"tcp","Data Access/Mgmt","Cassandra",
9160,"tcp","Data Access/Mgmt","Cassandra",
9200,"tcp","Data Access/Mgmt","Elastic Search",
9300,"tcp","Data Access/Mgmt","Elastic Search",
9987,"udp","3rd Party Attack","DSM/SCM Target Interface",
11211,"udp","Unencrypted","Memcached",
16379,"tcp","Data Access/Mgmt","Redis",
26379,"tcp","Data Access/Mgmt","Redis",
27017,"tcp","Data Access/Mgmt","MongoDB",
];
HighRiskPorts
| join kind=inner (
  CommonSecurityLog
  | where DeviceVendor == "Palo Alto Networks" and Activity == "TRAFFIC" and DeviceAction != "deny"
  | where SentBytes > 0 and ReceivedBytes > 0
  //Remove private IP communation from DestinationIP
  | extend result = ipv4_is_private(DestinationIP) 
  | where result == 0
  | summarize
      Count = count(),
      StartTime = min(TimeGenerated),
      EndTime = max(TimeGenerated)
      by 
      DeviceName,
      SourceIP,
      DestinationIP,
      DestinationPort,
      Protocol
) on $left.Port == $right.DestinationPort and $left.Protocol == $right.Protocol
| project-away Protocol1, Port
| order by DeviceName asc, SourceIP asc, DestinationIP asc, DestinationPort asc
| extend timestamp = StartTime, IPCustomEntity = SourceIP

```

## Palo Alto - high-risk ports

'Identifies network connections whose ports are frequent targets of attacks and should not cross network boundaries or reach untrusted public networks.
Consider updating the firewall policies to block the connections.'

|Name | Value |
| --- | --- |
|Tactic | Discovery|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 0a57accf-3548-4e38-a861-99687c958f59 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/PaloAlto-HighRiskPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let HighRiskPorts = datatable (Port:int, Protocol:string, RiskType:string, RiskDescription:string)[
13,"udp","3rd Party Attacks","Daytime protocol used in reflection/amplification attacks",
17,"udp","3rd Party Attacks","QOTD protocol, reflection/amplification attacks",
19,"udp","3rd Party Attacks","Chargen protocol, reflection/amplification attacks",
20,"tcp","Unencrypted","Unencrypted FTP Traffic",
21,"tcp","Unencrypted","Unencrypted FTP Traffic",
22,"tcp","Management","SSH, brute force attacks common",
23,"tcp","Management","Telnet, allows unauthenticated and/or unencrypted",
53,"udp","3rd Party Attacks","DNS, reflection/amplification attacks",
69,"udp","Management","TFTP, allows unauthenticated and/or unencrypted",
111,"udp","Management","RPC, unencrypted authentication allowed",
111,"tcp","Management","RPC, unencrypted authentication allowed",
119,"tcp","Unsecure","NNTP, unencrypted authentication",
123,"udp","3rd Party Attacks","Network Time Protocol, reflection/amplification attacks",
135,"tcp","Management","End Point Mapper, multiple remote management srvcs",
135,"udp","Management","End Point Mapper, multiple remote management srvcs",
137,"tcp","Hacker Recon","Netbios Name Service",
137,"udp","Hacker Recon","Netbios Name Service",
138,"tcp","Hacker Recon","Netbios Datagram Service",
138,"udp","Hacker Recon","Netbios Datagram Service",
139,"tcp","Hacker Recon","Netbios Session Service",
161,"tcp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
161,"udp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
162,"tcp","Unsecure","SNMP Trap, unsecure / no authentication",
162,"udp","Unsecure","SNMP Trap, unsecure / no authentication",
389,"tcp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
389,"udp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
443,"udp","3rd Party Attacks","UDP Reflection / Amplification attacks",
445,"tcp","Unsecure","SMB - well known attack vector",
512,"tcp","Management","Rexec on Linux, remote commands w/o encrypt auth",
514,"tcp","Management","Remote Shell, remote commands w/o auth or encrypt",
593,"tcp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
593,"udp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
636,"tcp","Hacker Recon","Lightweight Directory Access Protocol",
873,"tcp","Management","Rsync, unencrypted file transfer",
1433,"tcp","Data Access/Mgmt","MS SQL Management & Data Access",
1434,"udp","Data Access/Mgmt","MS SQL Monitor Port",
1900,"udp","Hacker Recon/3rd Party Attacks","Simple Service Discovery Protocol, unencrypted",
2049,"tcp","Unsecure","Network File System",
2049,"udp","Unsecure","Network File System",
2301,"tcp","Hacker Recon","Compaq Management Service, no recent incidents",
2381,"tcp","Management","Compaq Management Service, no recent incidents",
3268,"tcp","Hacker Recon","Microsoft Global Catalog LDAP",
3306,"tcp","Data Access/Mgmt","MySQL Database Management Port",
3389,"tcp","Management/3rd Party Attacks","RDP, Common brute force attack port",
3389,"udp","Management/3rd Party Attacks","RDP, Common brute force attack port",
4333,"tcp","Data Access/Mgmt","MSql",
5353,"udp","3rd Party Attacks","mDNS",
5432,"tcp","Data Access/Mgmt","PostgresSQL Database Management",
5800,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5900,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5985,"tcp","Management","Windows Powershell",
5986,"tcp","Management","Windows Powershell",
6379,"tcp","Data Access/Mgmt","Redis",
7000,"tcp","Data Access/Mgmt","Cassandra",
7001,"tcp","Data Access/Mgmt","Cassandra",
7199,"tcp","Data Access/Mgmt","Cassandra",
9042,"tcp","Data Access/Mgmt","Cassandra",
9160,"tcp","Data Access/Mgmt","Cassandra",
9200,"tcp","Data Access/Mgmt","Elastic Search",
9300,"tcp","Data Access/Mgmt","Elastic Search",
9987,"udp","3rd Party Attack","DSM/SCM Target Interface",
11211,"udp","Unencrypted","Memcached",
16379,"tcp","Data Access/Mgmt","Redis",
26379,"tcp","Data Access/Mgmt","Redis",
27017,"tcp","Data Access/Mgmt","MongoDB",
];
HighRiskPorts
| join kind=inner (
  CommonSecurityLog
  | where DeviceVendor == "Palo Alto Networks" and Activity == "TRAFFIC" and DeviceAction != "deny"
  | where SentBytes > 0 and ReceivedBytes > 0
  //Remove private IP communation from DestinationIP
  | extend result = ipv4_is_private(DestinationIP) 
  | where result == 0
  | summarize
      Count = count(),
      StartTime = min(TimeGenerated),
      EndTime = max(TimeGenerated)
      by 
      DeviceName,
      SourceIP,
      DestinationIP,
      DestinationPort,
      Protocol
) on $left.Port == $right.DestinationPort and $left.Protocol == $right.Protocol
| project-away Protocol1, Port
| order by DeviceName asc, SourceIP asc, DestinationIP asc, DestinationPort asc
| extend timestamp = StartTime, IPCustomEntity = SourceIP

```

## Palo Alto - high-risk ports

'Identifies network connections whose ports are frequent targets of attacks and should not cross network boundaries or reach untrusted public networks.
Consider updating the firewall policies to block the connections.'

|Name | Value |
| --- | --- |
|Tactic | Discovery|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 0a57accf-3548-4e38-a861-99687c958f59 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/PaloAlto-HighRiskPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let HighRiskPorts = datatable (Port:int, Protocol:string, RiskType:string, RiskDescription:string)[
13,"udp","3rd Party Attacks","Daytime protocol used in reflection/amplification attacks",
17,"udp","3rd Party Attacks","QOTD protocol, reflection/amplification attacks",
19,"udp","3rd Party Attacks","Chargen protocol, reflection/amplification attacks",
20,"tcp","Unencrypted","Unencrypted FTP Traffic",
21,"tcp","Unencrypted","Unencrypted FTP Traffic",
22,"tcp","Management","SSH, brute force attacks common",
23,"tcp","Management","Telnet, allows unauthenticated and/or unencrypted",
53,"udp","3rd Party Attacks","DNS, reflection/amplification attacks",
69,"udp","Management","TFTP, allows unauthenticated and/or unencrypted",
111,"udp","Management","RPC, unencrypted authentication allowed",
111,"tcp","Management","RPC, unencrypted authentication allowed",
119,"tcp","Unsecure","NNTP, unencrypted authentication",
123,"udp","3rd Party Attacks","Network Time Protocol, reflection/amplification attacks",
135,"tcp","Management","End Point Mapper, multiple remote management srvcs",
135,"udp","Management","End Point Mapper, multiple remote management srvcs",
137,"tcp","Hacker Recon","Netbios Name Service",
137,"udp","Hacker Recon","Netbios Name Service",
138,"tcp","Hacker Recon","Netbios Datagram Service",
138,"udp","Hacker Recon","Netbios Datagram Service",
139,"tcp","Hacker Recon","Netbios Session Service",
161,"tcp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
161,"udp","Unsecure/3rd Party Attacks","SNMP, unsecure / no authentication UDP Reflection attacks",
162,"tcp","Unsecure","SNMP Trap, unsecure / no authentication",
162,"udp","Unsecure","SNMP Trap, unsecure / no authentication",
389,"tcp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
389,"udp","Hacker Recon/3rd Party Attacks","LDAP/CLDAP",
443,"udp","3rd Party Attacks","UDP Reflection / Amplification attacks",
445,"tcp","Unsecure","SMB - well known attack vector",
512,"tcp","Management","Rexec on Linux, remote commands w/o encrypt auth",
514,"tcp","Management","Remote Shell, remote commands w/o auth or encrypt",
593,"tcp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
593,"udp","Management","HTTP RPC EPMAP, unencrypted remote procedure call",
636,"tcp","Hacker Recon","Lightweight Directory Access Protocol",
873,"tcp","Management","Rsync, unencrypted file transfer",
1433,"tcp","Data Access/Mgmt","MS SQL Management & Data Access",
1434,"udp","Data Access/Mgmt","MS SQL Monitor Port",
1900,"udp","Hacker Recon/3rd Party Attacks","Simple Service Discovery Protocol, unencrypted",
2049,"tcp","Unsecure","Network File System",
2049,"udp","Unsecure","Network File System",
2301,"tcp","Hacker Recon","Compaq Management Service, no recent incidents",
2381,"tcp","Management","Compaq Management Service, no recent incidents",
3268,"tcp","Hacker Recon","Microsoft Global Catalog LDAP",
3306,"tcp","Data Access/Mgmt","MySQL Database Management Port",
3389,"tcp","Management/3rd Party Attacks","RDP, Common brute force attack port",
3389,"udp","Management/3rd Party Attacks","RDP, Common brute force attack port",
4333,"tcp","Data Access/Mgmt","MSql",
5353,"udp","3rd Party Attacks","mDNS",
5432,"tcp","Data Access/Mgmt","PostgresSQL Database Management",
5800,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5900,"tcp","Management","VNC Remote Frame Buffer over HTTP",
5985,"tcp","Management","Windows Powershell",
5986,"tcp","Management","Windows Powershell",
6379,"tcp","Data Access/Mgmt","Redis",
7000,"tcp","Data Access/Mgmt","Cassandra",
7001,"tcp","Data Access/Mgmt","Cassandra",
7199,"tcp","Data Access/Mgmt","Cassandra",
9042,"tcp","Data Access/Mgmt","Cassandra",
9160,"tcp","Data Access/Mgmt","Cassandra",
9200,"tcp","Data Access/Mgmt","Elastic Search",
9300,"tcp","Data Access/Mgmt","Elastic Search",
9987,"udp","3rd Party Attack","DSM/SCM Target Interface",
11211,"udp","Unencrypted","Memcached",
16379,"tcp","Data Access/Mgmt","Redis",
26379,"tcp","Data Access/Mgmt","Redis",
27017,"tcp","Data Access/Mgmt","MongoDB",
];
HighRiskPorts
| join kind=inner (
  CommonSecurityLog
  | where DeviceVendor == "Palo Alto Networks" and Activity == "TRAFFIC" and DeviceAction != "deny"
  | where SentBytes > 0 and ReceivedBytes > 0
  //Remove private IP communation from DestinationIP
  | extend result = ipv4_is_private(DestinationIP) 
  | where result == 0
  | summarize
      Count = count(),
      StartTime = min(TimeGenerated),
      EndTime = max(TimeGenerated)
      by 
      DeviceName,
      SourceIP,
      DestinationIP,
      DestinationPort,
      Protocol
) on $left.Port == $right.DestinationPort and $left.Protocol == $right.Protocol
| project-away Protocol1, Port
| order by DeviceName asc, SourceIP asc, DestinationIP asc, DestinationPort asc
| extend timestamp = StartTime, IPCustomEntity = SourceIP

```

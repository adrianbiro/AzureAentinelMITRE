# Rules: 5377-5397

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | AzureNetworkWatcher |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | AzureNetworkAnalytics_CL |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | AzureNetworkWatcher |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | AzureNetworkAnalytics_CL |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(VMInsights) |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | VMConnection |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(VMInsights) |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | VMConnection |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | AzureMonitor(VMInsights) |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | VMConnection |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureFirewall |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | AzureFirewall |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Connection from external IP to OMI related Ports

'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). 
 OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. 
 The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) 
 as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:
 Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093
 Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure
 Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession

|Name | Value |
| --- | --- |
|Tactic | InitialAccess|
|TechniqueId | T1190|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | AzureFirewall |
|DetectionId | 767b8f6d-8029-4c92-afe1-282167d9d49a |
|DataTypes | AzureDiagnostics |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let Port = dynamic(["5985","5986","1270"]); 
(union isfuzzy=true
(imNetworkSession
| extend result = ipv4_is_private(SrcIpAddr)
| where result == 0  and SrcIpAddr != "127.0.0.1"
| where DstPortNumber in (Port)
| where EventResult != 'Failure'
| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp 
),
(VMConnection
| where Direction == "inbound"
| extend result = ipv4_is_private(SourceIp)
| where result == 0  and SourceIp != "127.0.0.1"
| where ProcessName == 'omiengine'
| where DestinationPort in (Port)
| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp
),
(AzureNetworkAnalytics_CL
| extend result = ipv4_is_private(SrcIP_s) 
| where result == 0 and SrcIP_s != "127.0.0.1"
| where L7Protocol_s has 'wsman'
| where DestPort_d in (Port)
| parse VM_s with * '/' VM 
| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type
| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp
),
AzureDiagnostics
| where Category == "AzureFirewallNetworkRule" and OperationName == "AzureFirewallNatRuleLog"
| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort " was " Action " to " InternalIP ':' InternalPort
| where DestinationPort in (Port)
| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource
| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp
)
)

```

## Unicode Obfuscation in Command Line

'The query looks for Command Lines that contain non ASCII characaters. Insertion of these characters could be used to evade detections.
Command lines should be reviewed to determine whether inclusion of non ASCII characters was deliberate or not.
Ref: https://www.wietzebeukema.nl/blog/windows-command-line-obfuscation'

|Name | Value |
| --- | --- |
|Tactic | DefenseEvasion|
|TechniqueId | T1027|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | SecurityEvents |
|DetectionId | a953f304-12e4-48ae-bedc-d58fb1b0c6a6 |
|DataTypes | SecurityEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UnicodeObfuscationInCommandLine.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let lolbins = dynamic(["cmd.exe", "powershell.exe", "find.exe", "PowerShell_ISE.exe", "wmic.exe", "winrs.exe", "winrm.cmd", "whoami.exe", "wevtutil.exe", "vssadmin.exe", "vbc.exe", "tasklist.exe", "takeown.exe", "taskkill.exe", "systeminfo.exe", "schtasks.exe", "sc.exe", "route.exe", "robocopy.cmd", "regsrv32.exe", "ping.exe", "nslookup.exe", "netstat.exe", "netsh.exe", "net.exe", "msiexec.exe", "mpcmdrun.exe", "jsc.exe", "ipconfig.exe", "icals.exe", "forfiles.exe", "fltmc.exe", "findstr.exe", "curl.exe", "csc.exe", "cmstp.exe", "cmdkey.exe", "certutils.exe", "cacls.exe", "bitsadmin.exe", "at.exe", "arp.exe"]);
(union isfuzzy=true
(SecurityEvent
| where Process in~ (lolbins)
| where isnotempty(CommandLine)
| extend CommandLine = translate('–”“', '-""', CommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false),
(DeviceProcessEvents
| where isnotempty(InitiatingProcessCommandLine)
| extend CommandLine = translate('–”“', '-""', InitiatingProcessCommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false
| extend Account = AccountName, Computer = DeviceName),
(imProcessCreate
| where isnotempty(ActingProcessCommandLine)
| extend CommandLine = translate('–”“', '-""', ActingProcessCommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false
| extend Account = ActorUsername, Computer = DvcHostname))
| summarize Computers=make_set(Computer), Users=make_set(Account), NumberOfTimesRun = count(TimeGenerated), FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, CommandLine
| extend NumberOfComputers = array_length(Computers), NumberOfUsers = array_length(Users)
| project-reorder FirstSeen, LastSeen, CommandLine, Process, NumberOfComputers, NumberOfComputers, NumberOfTimesRun, Computers, Users
| extend timestamp = FirstSeen

```

## Unicode Obfuscation in Command Line

'The query looks for Command Lines that contain non ASCII characaters. Insertion of these characters could be used to evade detections.
Command lines should be reviewed to determine whether inclusion of non ASCII characters was deliberate or not.
Ref: https://www.wietzebeukema.nl/blog/windows-command-line-obfuscation'

|Name | Value |
| --- | --- |
|Tactic | DefenseEvasion|
|TechniqueId | T1027|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a953f304-12e4-48ae-bedc-d58fb1b0c6a6 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UnicodeObfuscationInCommandLine.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let lolbins = dynamic(["cmd.exe", "powershell.exe", "find.exe", "PowerShell_ISE.exe", "wmic.exe", "winrs.exe", "winrm.cmd", "whoami.exe", "wevtutil.exe", "vssadmin.exe", "vbc.exe", "tasklist.exe", "takeown.exe", "taskkill.exe", "systeminfo.exe", "schtasks.exe", "sc.exe", "route.exe", "robocopy.cmd", "regsrv32.exe", "ping.exe", "nslookup.exe", "netstat.exe", "netsh.exe", "net.exe", "msiexec.exe", "mpcmdrun.exe", "jsc.exe", "ipconfig.exe", "icals.exe", "forfiles.exe", "fltmc.exe", "findstr.exe", "curl.exe", "csc.exe", "cmstp.exe", "cmdkey.exe", "certutils.exe", "cacls.exe", "bitsadmin.exe", "at.exe", "arp.exe"]);
(union isfuzzy=true
(SecurityEvent
| where Process in~ (lolbins)
| where isnotempty(CommandLine)
| extend CommandLine = translate('–”“', '-""', CommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false),
(DeviceProcessEvents
| where isnotempty(InitiatingProcessCommandLine)
| extend CommandLine = translate('–”“', '-""', InitiatingProcessCommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false
| extend Account = AccountName, Computer = DeviceName),
(imProcessCreate
| where isnotempty(ActingProcessCommandLine)
| extend CommandLine = translate('–”“', '-""', ActingProcessCommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false
| extend Account = ActorUsername, Computer = DvcHostname))
| summarize Computers=make_set(Computer), Users=make_set(Account), NumberOfTimesRun = count(TimeGenerated), FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, CommandLine
| extend NumberOfComputers = array_length(Computers), NumberOfUsers = array_length(Users)
| project-reorder FirstSeen, LastSeen, CommandLine, Process, NumberOfComputers, NumberOfComputers, NumberOfTimesRun, Computers, Users
| extend timestamp = FirstSeen

```

## Unicode Obfuscation in Command Line

'The query looks for Command Lines that contain non ASCII characaters. Insertion of these characters could be used to evade detections.
Command lines should be reviewed to determine whether inclusion of non ASCII characters was deliberate or not.
Ref: https://www.wietzebeukema.nl/blog/windows-command-line-obfuscation'

|Name | Value |
| --- | --- |
|Tactic | DefenseEvasion|
|TechniqueId | T1027|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a953f304-12e4-48ae-bedc-d58fb1b0c6a6 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UnicodeObfuscationInCommandLine.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let lolbins = dynamic(["cmd.exe", "powershell.exe", "find.exe", "PowerShell_ISE.exe", "wmic.exe", "winrs.exe", "winrm.cmd", "whoami.exe", "wevtutil.exe", "vssadmin.exe", "vbc.exe", "tasklist.exe", "takeown.exe", "taskkill.exe", "systeminfo.exe", "schtasks.exe", "sc.exe", "route.exe", "robocopy.cmd", "regsrv32.exe", "ping.exe", "nslookup.exe", "netstat.exe", "netsh.exe", "net.exe", "msiexec.exe", "mpcmdrun.exe", "jsc.exe", "ipconfig.exe", "icals.exe", "forfiles.exe", "fltmc.exe", "findstr.exe", "curl.exe", "csc.exe", "cmstp.exe", "cmdkey.exe", "certutils.exe", "cacls.exe", "bitsadmin.exe", "at.exe", "arp.exe"]);
(union isfuzzy=true
(SecurityEvent
| where Process in~ (lolbins)
| where isnotempty(CommandLine)
| extend CommandLine = translate('–”“', '-""', CommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false),
(DeviceProcessEvents
| where isnotempty(InitiatingProcessCommandLine)
| extend CommandLine = translate('–”“', '-""', InitiatingProcessCommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false
| extend Account = AccountName, Computer = DeviceName),
(imProcessCreate
| where isnotempty(ActingProcessCommandLine)
| extend CommandLine = translate('–”“', '-""', ActingProcessCommandLine)
| extend ASCII = isascii(CommandLine)
| where ASCII == false
| extend Account = ActorUsername, Computer = DvcHostname))
| summarize Computers=make_set(Computer), Users=make_set(Account), NumberOfTimesRun = count(TimeGenerated), FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, CommandLine
| extend NumberOfComputers = array_length(Computers), NumberOfUsers = array_length(Users)
| project-reorder FirstSeen, LastSeen, CommandLine, Process, NumberOfComputers, NumberOfComputers, NumberOfTimesRun, Computers, Users
| extend timestamp = FirstSeen

```

## Failed service logon attempt by user account with available AuditData

'User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.
Additionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.
This can help to understand any events for this same user related to User or Group Management.
Results may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.
The associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.
Receiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 22f33a4c-e60f-4817-bbfe-9e2ed33cb596 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FailedSigninsWithAuditDetails.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let failLimit = 10;
let ipLimit = 3;
let failedSignins = SigninLogs
| where TimeGenerated between(starttime..endtime)
| where ResultType != "0" and AppDisplayName != "Windows Sign In"
| extend UserPrincipalName = tolower(UserPrincipalName)
| extend CityState = strcat(tostring(LocationDetails.city),"|", tostring(LocationDetails.state))
| extend Result = strcat(ResultType,"-",ResultDescription)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress),
CityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName),
FailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount,
Results, FailedLogonCount, Location, CityStates
| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit
| extend Activity = pack("IPAddresses", IPAddresses, "AppDisplayNames", AppDisplayNames, "Results", Results, "Location", Location, "CityStates", CityStates)
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity
| extend AccountCustomEntity = UserPrincipalName;
let accountMods = AuditLogs | where TimeGenerated >= ago(lookback)
| where Category == "UserManagement" or Category == "GroupManagement"
| extend ModProps = TargetResources.[0].modifiedProperties
| extend InitiatedBy = case(
isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),
isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),
"")
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)
| extend ModifiedProps = pack("PropertyName",PropertyName,"oldValue",oldValue,"newValue",newValue)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id
| extend AccountCustomEntity = UserPrincipalName;
// Gather only Audit data for UserPrincipalNames that we have Audit data for
let accountNameOnly = failedSignins | project UserPrincipalName;
let auditMods = accountNameOnly
| join kind= innerunique (
accountMods
) on UserPrincipalName;
let availableAudits = auditMods | project UserPrincipalName;
let signinsWithAudit = availableAudits
| join kind= innerunique (
failedSignins
) on UserPrincipalName;
// Union the Current Signin failures so we do not lose them with the Auditing data we do have
let activity = (union isfuzzy=true
signinsWithAudit, auditMods)
| order by StartTimeUtc, UserPrincipalName;
activity
| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id
| order by UserPrincipalName, StartTimeUtc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName

```

## Failed service logon attempt by user account with available AuditData

'User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.
Additionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.
This can help to understand any events for this same user related to User or Group Management.
Results may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.
The associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.
Receiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 22f33a4c-e60f-4817-bbfe-9e2ed33cb596 |
|DataTypes | SigninLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FailedSigninsWithAuditDetails.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let failLimit = 10;
let ipLimit = 3;
let failedSignins = SigninLogs
| where TimeGenerated between(starttime..endtime)
| where ResultType != "0" and AppDisplayName != "Windows Sign In"
| extend UserPrincipalName = tolower(UserPrincipalName)
| extend CityState = strcat(tostring(LocationDetails.city),"|", tostring(LocationDetails.state))
| extend Result = strcat(ResultType,"-",ResultDescription)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress),
CityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName),
FailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount,
Results, FailedLogonCount, Location, CityStates
| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit
| extend Activity = pack("IPAddresses", IPAddresses, "AppDisplayNames", AppDisplayNames, "Results", Results, "Location", Location, "CityStates", CityStates)
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity
| extend AccountCustomEntity = UserPrincipalName;
let accountMods = AuditLogs | where TimeGenerated >= ago(lookback)
| where Category == "UserManagement" or Category == "GroupManagement"
| extend ModProps = TargetResources.[0].modifiedProperties
| extend InitiatedBy = case(
isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),
isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),
"")
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)
| extend ModifiedProps = pack("PropertyName",PropertyName,"oldValue",oldValue,"newValue",newValue)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id
| extend AccountCustomEntity = UserPrincipalName;
// Gather only Audit data for UserPrincipalNames that we have Audit data for
let accountNameOnly = failedSignins | project UserPrincipalName;
let auditMods = accountNameOnly
| join kind= innerunique (
accountMods
) on UserPrincipalName;
let availableAudits = auditMods | project UserPrincipalName;
let signinsWithAudit = availableAudits
| join kind= innerunique (
failedSignins
) on UserPrincipalName;
// Union the Current Signin failures so we do not lose them with the Auditing data we do have
let activity = (union isfuzzy=true
signinsWithAudit, auditMods)
| order by StartTimeUtc, UserPrincipalName;
activity
| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id
| order by UserPrincipalName, StartTimeUtc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName

```

## Failed service logon attempt by user account with available AuditData

'User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.
Additionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.
This can help to understand any events for this same user related to User or Group Management.
Results may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.
The associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.
Receiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 22f33a4c-e60f-4817-bbfe-9e2ed33cb596 |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FailedSigninsWithAuditDetails.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let failLimit = 10;
let ipLimit = 3;
let failedSignins = SigninLogs
| where TimeGenerated between(starttime..endtime)
| where ResultType != "0" and AppDisplayName != "Windows Sign In"
| extend UserPrincipalName = tolower(UserPrincipalName)
| extend CityState = strcat(tostring(LocationDetails.city),"|", tostring(LocationDetails.state))
| extend Result = strcat(ResultType,"-",ResultDescription)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress),
CityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName),
FailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount,
Results, FailedLogonCount, Location, CityStates
| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit
| extend Activity = pack("IPAddresses", IPAddresses, "AppDisplayNames", AppDisplayNames, "Results", Results, "Location", Location, "CityStates", CityStates)
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity
| extend AccountCustomEntity = UserPrincipalName;
let accountMods = AuditLogs | where TimeGenerated >= ago(lookback)
| where Category == "UserManagement" or Category == "GroupManagement"
| extend ModProps = TargetResources.[0].modifiedProperties
| extend InitiatedBy = case(
isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),
isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),
"")
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)
| extend ModifiedProps = pack("PropertyName",PropertyName,"oldValue",oldValue,"newValue",newValue)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id
| extend AccountCustomEntity = UserPrincipalName;
// Gather only Audit data for UserPrincipalNames that we have Audit data for
let accountNameOnly = failedSignins | project UserPrincipalName;
let auditMods = accountNameOnly
| join kind= innerunique (
accountMods
) on UserPrincipalName;
let availableAudits = auditMods | project UserPrincipalName;
let signinsWithAudit = availableAudits
| join kind= innerunique (
failedSignins
) on UserPrincipalName;
// Union the Current Signin failures so we do not lose them with the Auditing data we do have
let activity = (union isfuzzy=true
signinsWithAudit, auditMods)
| order by StartTimeUtc, UserPrincipalName;
activity
| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id
| order by UserPrincipalName, StartTimeUtc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName

```

## Failed service logon attempt by user account with available AuditData

'User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.
Additionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.
This can help to understand any events for this same user related to User or Group Management.
Results may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.
The associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.
Receiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.'

|Name | Value |
| --- | --- |
|Tactic | CredentialAccess|
|TechniqueId | T1110|
|Platform | Azure AD|
|DetectionType | Hunting |
|ConnectorId | AzureActiveDirectory |
|DetectionId | 22f33a4c-e60f-4817-bbfe-9e2ed33cb596 |
|DataTypes | AuditLogs |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FailedSigninsWithAuditDetails.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let failLimit = 10;
let ipLimit = 3;
let failedSignins = SigninLogs
| where TimeGenerated between(starttime..endtime)
| where ResultType != "0" and AppDisplayName != "Windows Sign In"
| extend UserPrincipalName = tolower(UserPrincipalName)
| extend CityState = strcat(tostring(LocationDetails.city),"|", tostring(LocationDetails.state))
| extend Result = strcat(ResultType,"-",ResultDescription)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress),
CityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName),
FailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount,
Results, FailedLogonCount, Location, CityStates
| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit
| extend Activity = pack("IPAddresses", IPAddresses, "AppDisplayNames", AppDisplayNames, "Results", Results, "Location", Location, "CityStates", CityStates)
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity
| extend AccountCustomEntity = UserPrincipalName;
let accountMods = AuditLogs | where TimeGenerated >= ago(lookback)
| where Category == "UserManagement" or Category == "GroupManagement"
| extend ModProps = TargetResources.[0].modifiedProperties
| extend InitiatedBy = case(
isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),
isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),
"")
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)
| extend ModifiedProps = pack("PropertyName",PropertyName,"oldValue",oldValue,"newValue",newValue)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id
| extend AccountCustomEntity = UserPrincipalName;
// Gather only Audit data for UserPrincipalNames that we have Audit data for
let accountNameOnly = failedSignins | project UserPrincipalName;
let auditMods = accountNameOnly
| join kind= innerunique (
accountMods
) on UserPrincipalName;
let availableAudits = auditMods | project UserPrincipalName;
let signinsWithAudit = availableAudits
| join kind= innerunique (
failedSignins
) on UserPrincipalName;
// Union the Current Signin failures so we do not lose them with the Auditing data we do have
let activity = (union isfuzzy=true
signinsWithAudit, auditMods)
| order by StartTimeUtc, UserPrincipalName;
activity
| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id
| order by UserPrincipalName, StartTimeUtc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName

```

## RareDNSLookupWithDataTransfer

'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.
This can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.
Feel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | 06c52a66-fffe-4d3b-a05a-646ff65b7ec2 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let lookupThreshold = 21;
let lookbackint = 7;
let binvalue = 1;
let bintime = make_timespan(binvalue,0);
let avgCalc = starttime/1h;
// Identify all domain lookups before start time and after lookback time
let DomainLookups = DnsEvents
| where TimeGenerated between(ago(lookback)..starttime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize DomainCount = count() by Domain
| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;
// Common lookups should not include items that occurred more rarely over the lookback period.
let CommonLookups = DomainLookups
| where DailyAvgLookupCountOverLookback > lookupThreshold;
// Get current lookups to compare against the lookback period
let TodayLookups = DnsEvents
| where TimeGenerated between(starttime..endtime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses
| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;
// Remove Common Lookups from lookback period from Todays lookups
let UncommonLookupsToday = TodayLookups
| join kind=leftanti (
CommonLookups
)
on Domain;
// Join back the Daily Average Lookup Count to add context to rarity over lookback period
let RareLookups = UncommonLookupsToday | join kind= innerunique (
DomainLookups
) on Domain
| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;
let DNSIPBreakout = RareLookups
| extend DnsIPAddress = iff(IPAddresses has ",", split(IPAddresses, ","), todynamic(IPAddresses))
| mvexpand DnsIPAddress
| extend DnsIPAddress = tostring(DnsIPAddress)
| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback
| extend IPCustomEntity = DnsIPAddress
| where ipv4_is_private(DnsIPAddress) == false
;
let DataMovement = ( union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between(starttime..endtime)
| where DeviceVendor =="Palo Alto Networks" and Activity == "TRAFFIC"
| where ipv4_is_private(DestinationIP) == false
| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| sort by sum_SentBytes desc
),
(WireData
| where TimeGenerated between(starttime..endtime)
| where Direction == "Outbound"
| where ipv4_is_private(RemoteIP) == false
| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| extend DataType = Type
| sort by sum_SentBytes desc
),
(VMConnection
| where TimeGenerated between(starttime..endtime)
| where Direction == "outbound"
| where ipv4_is_private(DestinationIp) == false
| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort
| sort by sum_SentBytes desc
| extend IPCustomEntity = DestinationIP
)
);
DNSIPBreakout | join kind = leftouter (
DataMovement
) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP
| project-away DnsIPAddress, ClientIP
// The below condition can be removed to see all DNS results.
// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP
| where isnotempty(DataType)
| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP

```

## RareDNSLookupWithDataTransfer

'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.
This can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.
Feel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | 06c52a66-fffe-4d3b-a05a-646ff65b7ec2 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let lookupThreshold = 21;
let lookbackint = 7;
let binvalue = 1;
let bintime = make_timespan(binvalue,0);
let avgCalc = starttime/1h;
// Identify all domain lookups before start time and after lookback time
let DomainLookups = DnsEvents
| where TimeGenerated between(ago(lookback)..starttime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize DomainCount = count() by Domain
| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;
// Common lookups should not include items that occurred more rarely over the lookback period.
let CommonLookups = DomainLookups
| where DailyAvgLookupCountOverLookback > lookupThreshold;
// Get current lookups to compare against the lookback period
let TodayLookups = DnsEvents
| where TimeGenerated between(starttime..endtime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses
| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;
// Remove Common Lookups from lookback period from Todays lookups
let UncommonLookupsToday = TodayLookups
| join kind=leftanti (
CommonLookups
)
on Domain;
// Join back the Daily Average Lookup Count to add context to rarity over lookback period
let RareLookups = UncommonLookupsToday | join kind= innerunique (
DomainLookups
) on Domain
| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;
let DNSIPBreakout = RareLookups
| extend DnsIPAddress = iff(IPAddresses has ",", split(IPAddresses, ","), todynamic(IPAddresses))
| mvexpand DnsIPAddress
| extend DnsIPAddress = tostring(DnsIPAddress)
| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback
| extend IPCustomEntity = DnsIPAddress
| where ipv4_is_private(DnsIPAddress) == false
;
let DataMovement = ( union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between(starttime..endtime)
| where DeviceVendor =="Palo Alto Networks" and Activity == "TRAFFIC"
| where ipv4_is_private(DestinationIP) == false
| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| sort by sum_SentBytes desc
),
(WireData
| where TimeGenerated between(starttime..endtime)
| where Direction == "Outbound"
| where ipv4_is_private(RemoteIP) == false
| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| extend DataType = Type
| sort by sum_SentBytes desc
),
(VMConnection
| where TimeGenerated between(starttime..endtime)
| where Direction == "outbound"
| where ipv4_is_private(DestinationIp) == false
| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort
| sort by sum_SentBytes desc
| extend IPCustomEntity = DestinationIP
)
);
DNSIPBreakout | join kind = leftouter (
DataMovement
) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP
| project-away DnsIPAddress, ClientIP
// The below condition can be removed to see all DNS results.
// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP
| where isnotempty(DataType)
| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP

```

## RareDNSLookupWithDataTransfer

'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.
This can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.
Feel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Linux|
|DetectionType | Hunting |
|ConnectorId | DNS |
|DetectionId | 06c52a66-fffe-4d3b-a05a-646ff65b7ec2 |
|DataTypes | DnsEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let lookupThreshold = 21;
let lookbackint = 7;
let binvalue = 1;
let bintime = make_timespan(binvalue,0);
let avgCalc = starttime/1h;
// Identify all domain lookups before start time and after lookback time
let DomainLookups = DnsEvents
| where TimeGenerated between(ago(lookback)..starttime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize DomainCount = count() by Domain
| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;
// Common lookups should not include items that occurred more rarely over the lookback period.
let CommonLookups = DomainLookups
| where DailyAvgLookupCountOverLookback > lookupThreshold;
// Get current lookups to compare against the lookback period
let TodayLookups = DnsEvents
| where TimeGenerated between(starttime..endtime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses
| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;
// Remove Common Lookups from lookback period from Todays lookups
let UncommonLookupsToday = TodayLookups
| join kind=leftanti (
CommonLookups
)
on Domain;
// Join back the Daily Average Lookup Count to add context to rarity over lookback period
let RareLookups = UncommonLookupsToday | join kind= innerunique (
DomainLookups
) on Domain
| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;
let DNSIPBreakout = RareLookups
| extend DnsIPAddress = iff(IPAddresses has ",", split(IPAddresses, ","), todynamic(IPAddresses))
| mvexpand DnsIPAddress
| extend DnsIPAddress = tostring(DnsIPAddress)
| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback
| extend IPCustomEntity = DnsIPAddress
| where ipv4_is_private(DnsIPAddress) == false
;
let DataMovement = ( union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between(starttime..endtime)
| where DeviceVendor =="Palo Alto Networks" and Activity == "TRAFFIC"
| where ipv4_is_private(DestinationIP) == false
| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| sort by sum_SentBytes desc
),
(WireData
| where TimeGenerated between(starttime..endtime)
| where Direction == "Outbound"
| where ipv4_is_private(RemoteIP) == false
| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| extend DataType = Type
| sort by sum_SentBytes desc
),
(VMConnection
| where TimeGenerated between(starttime..endtime)
| where Direction == "outbound"
| where ipv4_is_private(DestinationIp) == false
| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort
| sort by sum_SentBytes desc
| extend IPCustomEntity = DestinationIP
)
);
DNSIPBreakout | join kind = leftouter (
DataMovement
) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP
| project-away DnsIPAddress, ClientIP
// The below condition can be removed to see all DNS results.
// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP
| where isnotempty(DataType)
| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP

```

## RareDNSLookupWithDataTransfer

'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.
This can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.
Feel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 06c52a66-fffe-4d3b-a05a-646ff65b7ec2 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let lookupThreshold = 21;
let lookbackint = 7;
let binvalue = 1;
let bintime = make_timespan(binvalue,0);
let avgCalc = starttime/1h;
// Identify all domain lookups before start time and after lookback time
let DomainLookups = DnsEvents
| where TimeGenerated between(ago(lookback)..starttime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize DomainCount = count() by Domain
| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;
// Common lookups should not include items that occurred more rarely over the lookback period.
let CommonLookups = DomainLookups
| where DailyAvgLookupCountOverLookback > lookupThreshold;
// Get current lookups to compare against the lookback period
let TodayLookups = DnsEvents
| where TimeGenerated between(starttime..endtime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses
| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;
// Remove Common Lookups from lookback period from Todays lookups
let UncommonLookupsToday = TodayLookups
| join kind=leftanti (
CommonLookups
)
on Domain;
// Join back the Daily Average Lookup Count to add context to rarity over lookback period
let RareLookups = UncommonLookupsToday | join kind= innerunique (
DomainLookups
) on Domain
| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;
let DNSIPBreakout = RareLookups
| extend DnsIPAddress = iff(IPAddresses has ",", split(IPAddresses, ","), todynamic(IPAddresses))
| mvexpand DnsIPAddress
| extend DnsIPAddress = tostring(DnsIPAddress)
| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback
| extend IPCustomEntity = DnsIPAddress
| where ipv4_is_private(DnsIPAddress) == false
;
let DataMovement = ( union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between(starttime..endtime)
| where DeviceVendor =="Palo Alto Networks" and Activity == "TRAFFIC"
| where ipv4_is_private(DestinationIP) == false
| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| sort by sum_SentBytes desc
),
(WireData
| where TimeGenerated between(starttime..endtime)
| where Direction == "Outbound"
| where ipv4_is_private(RemoteIP) == false
| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| extend DataType = Type
| sort by sum_SentBytes desc
),
(VMConnection
| where TimeGenerated between(starttime..endtime)
| where Direction == "outbound"
| where ipv4_is_private(DestinationIp) == false
| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort
| sort by sum_SentBytes desc
| extend IPCustomEntity = DestinationIP
)
);
DNSIPBreakout | join kind = leftouter (
DataMovement
) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP
| project-away DnsIPAddress, ClientIP
// The below condition can be removed to see all DNS results.
// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP
| where isnotempty(DataType)
| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP

```

## RareDNSLookupWithDataTransfer

'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.
This can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.
Feel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'

|Name | Value |
| --- | --- |
|Tactic | CommandAndControl|
|TechniqueId | T1071|
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | PaloAltoNetworks |
|DetectionId | 06c52a66-fffe-4d3b-a05a-646ff65b7ec2 |
|DataTypes | CommonSecurityLog |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql

let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = totimespan((endtime-starttime)*7);
let lookupThreshold = 21;
let lookbackint = 7;
let binvalue = 1;
let bintime = make_timespan(binvalue,0);
let avgCalc = starttime/1h;
// Identify all domain lookups before start time and after lookback time
let DomainLookups = DnsEvents
| where TimeGenerated between(ago(lookback)..starttime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize DomainCount = count() by Domain
| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;
// Common lookups should not include items that occurred more rarely over the lookback period.
let CommonLookups = DomainLookups
| where DailyAvgLookupCountOverLookback > lookupThreshold;
// Get current lookups to compare against the lookback period
let TodayLookups = DnsEvents
| where TimeGenerated between(starttime..endtime)
| where SubType == "LookupQuery"
| where isnotempty(IPAddresses)
| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)
| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses
| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;
// Remove Common Lookups from lookback period from Todays lookups
let UncommonLookupsToday = TodayLookups
| join kind=leftanti (
CommonLookups
)
on Domain;
// Join back the Daily Average Lookup Count to add context to rarity over lookback period
let RareLookups = UncommonLookupsToday | join kind= innerunique (
DomainLookups
) on Domain
| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;
let DNSIPBreakout = RareLookups
| extend DnsIPAddress = iff(IPAddresses has ",", split(IPAddresses, ","), todynamic(IPAddresses))
| mvexpand DnsIPAddress
| extend DnsIPAddress = tostring(DnsIPAddress)
| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback
| extend IPCustomEntity = DnsIPAddress
| where ipv4_is_private(DnsIPAddress) == false
;
let DataMovement = ( union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between(starttime..endtime)
| where DeviceVendor =="Palo Alto Networks" and Activity == "TRAFFIC"
| where ipv4_is_private(DestinationIP) == false
| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes
| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| sort by sum_SentBytes desc
),
(WireData
| where TimeGenerated between(starttime..endtime)
| where Direction == "Outbound"
| where ipv4_is_private(RemoteIP) == false
| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort
| extend IPCustomEntity = DestinationIP
| extend DataType = Type
| sort by sum_SentBytes desc
),
(VMConnection
| where TimeGenerated between(starttime..endtime)
| where Direction == "outbound"
| where ipv4_is_private(DestinationIp) == false
| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent
| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort
| sort by sum_SentBytes desc
| extend IPCustomEntity = DestinationIP
)
);
DNSIPBreakout | join kind = leftouter (
DataMovement
) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP
| project-away DnsIPAddress, ClientIP
// The below condition can be removed to see all DNS results.
// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP
| where isnotempty(DataType)
| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP

```

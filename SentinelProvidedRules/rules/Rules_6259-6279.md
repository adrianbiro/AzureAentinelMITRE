# Rules: 6259-6279

## Open email link

Query for links opened from mail apps - if a detection occurred right afterwards.
As there are many links opened from mails, to have a successful hunt we should have some filter or join with some other signal,.
Such as suspicious processes, network connections, etc.
Therefore, in this example, we query for alerts that might be related to links sent via email.
This could be indicative of a phishing or spear-phishing attacks.
Tags: #EmailLink, #Phishing, #GetNearbyAlerts.
Explaining the underlying data:.
This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.
For this event, RemoteUrl contains the opened URL.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 67be3fdd-6942-45f8-8663-d825b61d1ab9 |
|DataTypes | AlertEvidence |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Open%20email%20link.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Query for links opened from mail apps - if a detection occurred right afterwards. - MTP Schema
// As there are many links opened from mails, to have a successful hunt we should have some filter or join with some other signal,
// such as suspicious processes, network connections, etc.
// Therefore, in this example, we query for alerts that might be related to links sent via email.
// This could be indicative of a phishing or spear-phishing attacks.
// Tags: #EmailLink, #Phishing, #GetNearbyAlerts
// Explaining the underlying data:
//     This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files
//     For this event, RemoteUrl contains the opened URL.
let minTimeRange = ago(7d);
let outlookLinks = 
    DeviceEvents
    // Filter on click on links from outlook
    | where Timestamp > minTimeRange and ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl)
	| where 
			// outlook.exe is the Office Outlook app
			InitiatingProcessFileName =~ "outlook.exe" 
			// RuntimeBroker.exe opens links for all apps from the Windows store, including the Windows Mail app (HxOutlook.exe).
			// However, it will also include some links opened from other apps.			
	        or InitiatingProcessFileName =~ "runtimebroker.exe"
    | project Timestamp, DeviceId, DeviceName, RemoteUrl, InitiatingProcessFileName, ParsedUrl=parse_url(RemoteUrl)
    // When applicable, parse the link sent via email from the clicked O365 ATP SafeLink
    | extend WasOutlookSafeLink=(tostring(ParsedUrl.Host) endswith "safelinks.protection.outlook.com")
    | project Timestamp, DeviceId, DeviceName, WasOutlookSafeLink, InitiatingProcessFileName,
            OpenedLink=iff(WasOutlookSafeLink, url_decode(tostring(ParsedUrl["Query Parameters"]["url"])), RemoteUrl);
let alerts =
    AlertInfo | join AlertEvidence on AlertId
    | summarize (FirstDetectedActivity, Title)=argmin(Timestamp, Title) by AlertId, DeviceId
    // Filter alerts that include events from before the queried time period
    | where FirstDetectedActivity > minTimeRange;
// Join the two together - looking for alerts that are right after an abnormal network logon
alerts | join kind=inner (outlookLinks) on DeviceId | where FirstDetectedActivity - Timestamp between (0min..3min)
// If there are multiple alerts close to a single click-on-link, aggregate them together to a single row
// Note: bin(Timestamp, 1tick) is used because when summarizing by a datetime field, the default "bin" used is 1-hour.
| summarize FirstDetectedActivity=min(FirstDetectedActivity), AlertTitles=makeset(Title) by OpenedLink, InitiatingProcessFileName, Timestamp=bin(Timestamp, 1tick), DeviceName, DeviceId, WasOutlookSafeLink

```

## Qakbot Craigslist Domains

Qakbot operators have been abusing the Craigslist messaging system to send malicious emails. These emails contain non-clickable links to malicious domains impersonating Craigslist, which the user is instructed to manually type into the address bar to access.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 5fa50982-9337-4c5f-b8de-cfa871b8f40f |
|DataTypes | DeviceNetworkEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Qakbot%20Craigslist%20Domains.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
DeviceNetworkEvents
| where RemoteUrl matches regex @"abuse\.[a-zA-Z]\d{2}-craigslist\.org"

```

## Qakbot Craigslist Domains

Qakbot operators have been abusing the Craigslist messaging system to send malicious emails. These emails contain non-clickable links to malicious domains impersonating Craigslist, which the user is instructed to manually type into the address bar to access.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 5fa50982-9337-4c5f-b8de-cfa871b8f40f |
|DataTypes | DeviceNetworkEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Qakbot%20Craigslist%20Domains.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
DeviceNetworkEvents
| where RemoteUrl matches regex @"abuse\.[a-zA-Z]\d{2}-craigslist\.org"

```

## Doc attachment with link to download

This query looks for a Word document attachment, from which a link was clicked, and after which there was a browser download.
This query is not noisy, but most of its results are clean.
It can also hserve as reference for other queries on email attachments, on browser downloads or for queries that join multiple events by time.
Tags: #EmailAttachment, #WordLink, #BrowserDownload, #Phishing, #DedupFileCreate.
Implementation comment #1: Matching events by time.
Matching the 3 different events (saving attachment, clicking on link, downloading file) is done purely by time difference - so could sometimes link together unrelated events.
Doing a more exact lookup would create a much more complex query due to.
Implementation comment #2: Deduping DeviceFileEvents.
Oftentimes there are multiple DeviceFileEvents for a single file - e.g. if the file keeps being appended into before being closed.
So, we query only for the last reported file state to ignore intermediate file states.
Explaining the underlying data:.
BrowserLaunchedToOpenUrl event:.
This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.
For this event, RemoteUrl contains the opened URL.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | cf259a7a-801a-435a-af3f-3ef998561145 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Doc%20attachment%20with%20link%20to%20download.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTimeRange = ago(7d);
let wordLinks = 
    DeviceEvents
    // Filter on click on links from WinWord
    | where Timestamp > minTimeRange and ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "winword.exe"
    | project ClickTime=Timestamp, DeviceId, DeviceName, ClickUrl=RemoteUrl;
let docAttachments = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for common document file extensions
            and (FileName endswith ".docx" or FileName endswith ".docm" or FileName endswith ".doc")
			// Query for files saved from email clients such as the Office Outlook app or the Windows Mail app
            and InitiatingProcessFileName in~ ("outlook.exe", "hxoutlook.exe")
    | summarize AttachmentSaveTime=min(Timestamp) by AttachmentName=FileName, DeviceId;
let browserDownloads = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for files created by common browsers
            and InitiatingProcessFileName in~ ("browser_broker.exe", "chrome.exe", "iexplore.exe", "firefox.exe")
            // Exclude JS files that are used for loading sites (but still query for JS files that are known to be downloaded)
            and not (FileName endswith ".js" and isempty(FileOriginUrl))
    // Further filter to exclude file extensions that are less indicative of an attack (when there were already previously a doc attachment that included a link)
    | where FileName !endswith ".partial" and FileName !endswith ".docx"
    | summarize (Timestamp, SHA1) = argmax(Timestamp, SHA1) by FileName, DeviceId, FileOriginUrl;
// Perf tip: start the joins from the smallest table (put it on the left-most side of the joins)
wordLinks
| join kind= inner (docAttachments) on DeviceId | where ClickTime - AttachmentSaveTime between (0min..3min)
| join kind= inner (browserDownloads) on DeviceId | where Timestamp - ClickTime between (0min..3min) 
// Aggregating multiple "attachments" together - because oftentimes the same file is stored multiple times under different names
| summarize Attachments=makeset(AttachmentName), AttachmentSaveTime=min(AttachmentSaveTime), ClickTime=min(ClickTime)
    by // Downloaded file details
        bin(Timestamp, 1tick), FileName, FileOriginUrl, ClickUrl, SHA1, DeviceName, DeviceId

```

## Doc attachment with link to download

This query looks for a Word document attachment, from which a link was clicked, and after which there was a browser download.
This query is not noisy, but most of its results are clean.
It can also hserve as reference for other queries on email attachments, on browser downloads or for queries that join multiple events by time.
Tags: #EmailAttachment, #WordLink, #BrowserDownload, #Phishing, #DedupFileCreate.
Implementation comment #1: Matching events by time.
Matching the 3 different events (saving attachment, clicking on link, downloading file) is done purely by time difference - so could sometimes link together unrelated events.
Doing a more exact lookup would create a much more complex query due to.
Implementation comment #2: Deduping DeviceFileEvents.
Oftentimes there are multiple DeviceFileEvents for a single file - e.g. if the file keeps being appended into before being closed.
So, we query only for the last reported file state to ignore intermediate file states.
Explaining the underlying data:.
BrowserLaunchedToOpenUrl event:.
This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.
For this event, RemoteUrl contains the opened URL.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | cf259a7a-801a-435a-af3f-3ef998561145 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Doc%20attachment%20with%20link%20to%20download.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTimeRange = ago(7d);
let wordLinks = 
    DeviceEvents
    // Filter on click on links from WinWord
    | where Timestamp > minTimeRange and ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "winword.exe"
    | project ClickTime=Timestamp, DeviceId, DeviceName, ClickUrl=RemoteUrl;
let docAttachments = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for common document file extensions
            and (FileName endswith ".docx" or FileName endswith ".docm" or FileName endswith ".doc")
			// Query for files saved from email clients such as the Office Outlook app or the Windows Mail app
            and InitiatingProcessFileName in~ ("outlook.exe", "hxoutlook.exe")
    | summarize AttachmentSaveTime=min(Timestamp) by AttachmentName=FileName, DeviceId;
let browserDownloads = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for files created by common browsers
            and InitiatingProcessFileName in~ ("browser_broker.exe", "chrome.exe", "iexplore.exe", "firefox.exe")
            // Exclude JS files that are used for loading sites (but still query for JS files that are known to be downloaded)
            and not (FileName endswith ".js" and isempty(FileOriginUrl))
    // Further filter to exclude file extensions that are less indicative of an attack (when there were already previously a doc attachment that included a link)
    | where FileName !endswith ".partial" and FileName !endswith ".docx"
    | summarize (Timestamp, SHA1) = argmax(Timestamp, SHA1) by FileName, DeviceId, FileOriginUrl;
// Perf tip: start the joins from the smallest table (put it on the left-most side of the joins)
wordLinks
| join kind= inner (docAttachments) on DeviceId | where ClickTime - AttachmentSaveTime between (0min..3min)
| join kind= inner (browserDownloads) on DeviceId | where Timestamp - ClickTime between (0min..3min) 
// Aggregating multiple "attachments" together - because oftentimes the same file is stored multiple times under different names
| summarize Attachments=makeset(AttachmentName), AttachmentSaveTime=min(AttachmentSaveTime), ClickTime=min(ClickTime)
    by // Downloaded file details
        bin(Timestamp, 1tick), FileName, FileOriginUrl, ClickUrl, SHA1, DeviceName, DeviceId

```

## Doc attachment with link to download

This query looks for a Word document attachment, from which a link was clicked, and after which there was a browser download.
This query is not noisy, but most of its results are clean.
It can also hserve as reference for other queries on email attachments, on browser downloads or for queries that join multiple events by time.
Tags: #EmailAttachment, #WordLink, #BrowserDownload, #Phishing, #DedupFileCreate.
Implementation comment #1: Matching events by time.
Matching the 3 different events (saving attachment, clicking on link, downloading file) is done purely by time difference - so could sometimes link together unrelated events.
Doing a more exact lookup would create a much more complex query due to.
Implementation comment #2: Deduping DeviceFileEvents.
Oftentimes there are multiple DeviceFileEvents for a single file - e.g. if the file keeps being appended into before being closed.
So, we query only for the last reported file state to ignore intermediate file states.
Explaining the underlying data:.
BrowserLaunchedToOpenUrl event:.
This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.
For this event, RemoteUrl contains the opened URL.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | cf259a7a-801a-435a-af3f-3ef998561145 |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Doc%20attachment%20with%20link%20to%20download.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTimeRange = ago(7d);
let wordLinks = 
    DeviceEvents
    // Filter on click on links from WinWord
    | where Timestamp > minTimeRange and ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "winword.exe"
    | project ClickTime=Timestamp, DeviceId, DeviceName, ClickUrl=RemoteUrl;
let docAttachments = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for common document file extensions
            and (FileName endswith ".docx" or FileName endswith ".docm" or FileName endswith ".doc")
			// Query for files saved from email clients such as the Office Outlook app or the Windows Mail app
            and InitiatingProcessFileName in~ ("outlook.exe", "hxoutlook.exe")
    | summarize AttachmentSaveTime=min(Timestamp) by AttachmentName=FileName, DeviceId;
let browserDownloads = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for files created by common browsers
            and InitiatingProcessFileName in~ ("browser_broker.exe", "chrome.exe", "iexplore.exe", "firefox.exe")
            // Exclude JS files that are used for loading sites (but still query for JS files that are known to be downloaded)
            and not (FileName endswith ".js" and isempty(FileOriginUrl))
    // Further filter to exclude file extensions that are less indicative of an attack (when there were already previously a doc attachment that included a link)
    | where FileName !endswith ".partial" and FileName !endswith ".docx"
    | summarize (Timestamp, SHA1) = argmax(Timestamp, SHA1) by FileName, DeviceId, FileOriginUrl;
// Perf tip: start the joins from the smallest table (put it on the left-most side of the joins)
wordLinks
| join kind= inner (docAttachments) on DeviceId | where ClickTime - AttachmentSaveTime between (0min..3min)
| join kind= inner (browserDownloads) on DeviceId | where Timestamp - ClickTime between (0min..3min) 
// Aggregating multiple "attachments" together - because oftentimes the same file is stored multiple times under different names
| summarize Attachments=makeset(AttachmentName), AttachmentSaveTime=min(AttachmentSaveTime), ClickTime=min(ClickTime)
    by // Downloaded file details
        bin(Timestamp, 1tick), FileName, FileOriginUrl, ClickUrl, SHA1, DeviceName, DeviceId

```

## Doc attachment with link to download

This query looks for a Word document attachment, from which a link was clicked, and after which there was a browser download.
This query is not noisy, but most of its results are clean.
It can also hserve as reference for other queries on email attachments, on browser downloads or for queries that join multiple events by time.
Tags: #EmailAttachment, #WordLink, #BrowserDownload, #Phishing, #DedupFileCreate.
Implementation comment #1: Matching events by time.
Matching the 3 different events (saving attachment, clicking on link, downloading file) is done purely by time difference - so could sometimes link together unrelated events.
Doing a more exact lookup would create a much more complex query due to.
Implementation comment #2: Deduping DeviceFileEvents.
Oftentimes there are multiple DeviceFileEvents for a single file - e.g. if the file keeps being appended into before being closed.
So, we query only for the last reported file state to ignore intermediate file states.
Explaining the underlying data:.
BrowserLaunchedToOpenUrl event:.
This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.
For this event, RemoteUrl contains the opened URL.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | cf259a7a-801a-435a-af3f-3ef998561145 |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Doc%20attachment%20with%20link%20to%20download.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTimeRange = ago(7d);
let wordLinks = 
    DeviceEvents
    // Filter on click on links from WinWord
    | where Timestamp > minTimeRange and ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "winword.exe"
    | project ClickTime=Timestamp, DeviceId, DeviceName, ClickUrl=RemoteUrl;
let docAttachments = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for common document file extensions
            and (FileName endswith ".docx" or FileName endswith ".docm" or FileName endswith ".doc")
			// Query for files saved from email clients such as the Office Outlook app or the Windows Mail app
            and InitiatingProcessFileName in~ ("outlook.exe", "hxoutlook.exe")
    | summarize AttachmentSaveTime=min(Timestamp) by AttachmentName=FileName, DeviceId;
let browserDownloads = 
    DeviceFileEvents
    | where Timestamp > minTimeRange 
			// Query for files created by common browsers
            and InitiatingProcessFileName in~ ("browser_broker.exe", "chrome.exe", "iexplore.exe", "firefox.exe")
            // Exclude JS files that are used for loading sites (but still query for JS files that are known to be downloaded)
            and not (FileName endswith ".js" and isempty(FileOriginUrl))
    // Further filter to exclude file extensions that are less indicative of an attack (when there were already previously a doc attachment that included a link)
    | where FileName !endswith ".partial" and FileName !endswith ".docx"
    | summarize (Timestamp, SHA1) = argmax(Timestamp, SHA1) by FileName, DeviceId, FileOriginUrl;
// Perf tip: start the joins from the smallest table (put it on the left-most side of the joins)
wordLinks
| join kind= inner (docAttachments) on DeviceId | where ClickTime - AttachmentSaveTime between (0min..3min)
| join kind= inner (browserDownloads) on DeviceId | where Timestamp - ClickTime between (0min..3min) 
// Aggregating multiple "attachments" together - because oftentimes the same file is stored multiple times under different names
| summarize Attachments=makeset(AttachmentName), AttachmentSaveTime=min(AttachmentSaveTime), ClickTime=min(ClickTime)
    by // Downloaded file details
        bin(Timestamp, 1tick), FileName, FileOriginUrl, ClickUrl, SHA1, DeviceName, DeviceId

```

## Pivot from detections to related downloads

Pivot from downloads detected by Windows Defender Antivirus to other files downloaded from the same sites.
To learn more about the download URL info that is available and see other sample queries,.
Check out this blog post: https://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 351f7035-836c-4f4b-80bb-188220ba9215 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Pivot%20from%20detections%20to%20related%20downloads.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let detectedDownloads =
    DeviceEvents
    | where ActionType == "AntivirusDetection" and isnotempty(FileOriginUrl)
    | project Timestamp, FileOriginUrl, FileName, DeviceId,
              ThreatName=tostring(parse_json(AdditionalFields).ThreatName)
    // Filter out less severe threat categories on which we do not want to pivot
    | where ThreatName !startswith "PUA"
            and ThreatName !startswith "SoftwareBundler:" 
            and FileOriginUrl != "about:internet";
let detectedDownloadsSummary =
    detectedDownloads
    // Get a few examples for each detected Host:
    // up to 4 filenames, up to 4 threat names, one full URL)
    | summarize DetectedUrl=any(FileOriginUrl),
                DetectedFiles=makeset(FileName, 4),
                ThreatNames=makeset(ThreatName, 4)
                by Host=tostring(parse_url(FileOriginUrl).Host);
// Query for downloads from sites from which other downloads were detected by Windows Defender Antivirus
DeviceFileEvents
| where isnotempty(FileOriginUrl)
| project FileName, FileOriginUrl, DeviceId, Timestamp,
          Host=tostring(parse_url(FileOriginUrl).Host), SHA1 
// Filter downloads from hosts serving detected files
| join kind=inner(detectedDownloadsSummary) on Host
// Filter out download file create events that were also detected.
// This is needed because sometimes both of these events will be reported, 
// and sometimes only the AntivirusDetection event - depending on timing.
| join kind=leftanti(detectedDownloads) on DeviceId, FileOriginUrl
// Summarize a single row per host - with the machines count 
// and an example event for a missed download (select the last event)
| summarize MachineCount=dcount(DeviceId), arg_max(Timestamp, *) by Host
// Filter out common hosts, as they probably ones that also serve benign files
| where MachineCount < 20
| project Host, MachineCount, DeviceId, FileName, DetectedFiles, 
          FileOriginUrl, DetectedUrl, ThreatNames, Timestamp, SHA1
| order by MachineCount desc 

```

## Pivot from detections to related downloads

Pivot from downloads detected by Windows Defender Antivirus to other files downloaded from the same sites.
To learn more about the download URL info that is available and see other sample queries,.
Check out this blog post: https://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 351f7035-836c-4f4b-80bb-188220ba9215 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Pivot%20from%20detections%20to%20related%20downloads.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let detectedDownloads =
    DeviceEvents
    | where ActionType == "AntivirusDetection" and isnotempty(FileOriginUrl)
    | project Timestamp, FileOriginUrl, FileName, DeviceId,
              ThreatName=tostring(parse_json(AdditionalFields).ThreatName)
    // Filter out less severe threat categories on which we do not want to pivot
    | where ThreatName !startswith "PUA"
            and ThreatName !startswith "SoftwareBundler:" 
            and FileOriginUrl != "about:internet";
let detectedDownloadsSummary =
    detectedDownloads
    // Get a few examples for each detected Host:
    // up to 4 filenames, up to 4 threat names, one full URL)
    | summarize DetectedUrl=any(FileOriginUrl),
                DetectedFiles=makeset(FileName, 4),
                ThreatNames=makeset(ThreatName, 4)
                by Host=tostring(parse_url(FileOriginUrl).Host);
// Query for downloads from sites from which other downloads were detected by Windows Defender Antivirus
DeviceFileEvents
| where isnotempty(FileOriginUrl)
| project FileName, FileOriginUrl, DeviceId, Timestamp,
          Host=tostring(parse_url(FileOriginUrl).Host), SHA1 
// Filter downloads from hosts serving detected files
| join kind=inner(detectedDownloadsSummary) on Host
// Filter out download file create events that were also detected.
// This is needed because sometimes both of these events will be reported, 
// and sometimes only the AntivirusDetection event - depending on timing.
| join kind=leftanti(detectedDownloads) on DeviceId, FileOriginUrl
// Summarize a single row per host - with the machines count 
// and an example event for a missed download (select the last event)
| summarize MachineCount=dcount(DeviceId), arg_max(Timestamp, *) by Host
// Filter out common hosts, as they probably ones that also serve benign files
| where MachineCount < 20
| project Host, MachineCount, DeviceId, FileName, DetectedFiles, 
          FileOriginUrl, DetectedUrl, ThreatNames, Timestamp, SHA1
| order by MachineCount desc 

```

## Pivot from detections to related downloads

Pivot from downloads detected by Windows Defender Antivirus to other files downloaded from the same sites.
To learn more about the download URL info that is available and see other sample queries,.
Check out this blog post: https://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 351f7035-836c-4f4b-80bb-188220ba9215 |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Pivot%20from%20detections%20to%20related%20downloads.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let detectedDownloads =
    DeviceEvents
    | where ActionType == "AntivirusDetection" and isnotempty(FileOriginUrl)
    | project Timestamp, FileOriginUrl, FileName, DeviceId,
              ThreatName=tostring(parse_json(AdditionalFields).ThreatName)
    // Filter out less severe threat categories on which we do not want to pivot
    | where ThreatName !startswith "PUA"
            and ThreatName !startswith "SoftwareBundler:" 
            and FileOriginUrl != "about:internet";
let detectedDownloadsSummary =
    detectedDownloads
    // Get a few examples for each detected Host:
    // up to 4 filenames, up to 4 threat names, one full URL)
    | summarize DetectedUrl=any(FileOriginUrl),
                DetectedFiles=makeset(FileName, 4),
                ThreatNames=makeset(ThreatName, 4)
                by Host=tostring(parse_url(FileOriginUrl).Host);
// Query for downloads from sites from which other downloads were detected by Windows Defender Antivirus
DeviceFileEvents
| where isnotempty(FileOriginUrl)
| project FileName, FileOriginUrl, DeviceId, Timestamp,
          Host=tostring(parse_url(FileOriginUrl).Host), SHA1 
// Filter downloads from hosts serving detected files
| join kind=inner(detectedDownloadsSummary) on Host
// Filter out download file create events that were also detected.
// This is needed because sometimes both of these events will be reported, 
// and sometimes only the AntivirusDetection event - depending on timing.
| join kind=leftanti(detectedDownloads) on DeviceId, FileOriginUrl
// Summarize a single row per host - with the machines count 
// and an example event for a missed download (select the last event)
| summarize MachineCount=dcount(DeviceId), arg_max(Timestamp, *) by Host
// Filter out common hosts, as they probably ones that also serve benign files
| where MachineCount < 20
| project Host, MachineCount, DeviceId, FileName, DetectedFiles, 
          FileOriginUrl, DetectedUrl, ThreatNames, Timestamp, SHA1
| order by MachineCount desc 

```

## Pivot from detections to related downloads

Pivot from downloads detected by Windows Defender Antivirus to other files downloaded from the same sites.
To learn more about the download URL info that is available and see other sample queries,.
Check out this blog post: https://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 351f7035-836c-4f4b-80bb-188220ba9215 |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Pivot%20from%20detections%20to%20related%20downloads.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let detectedDownloads =
    DeviceEvents
    | where ActionType == "AntivirusDetection" and isnotempty(FileOriginUrl)
    | project Timestamp, FileOriginUrl, FileName, DeviceId,
              ThreatName=tostring(parse_json(AdditionalFields).ThreatName)
    // Filter out less severe threat categories on which we do not want to pivot
    | where ThreatName !startswith "PUA"
            and ThreatName !startswith "SoftwareBundler:" 
            and FileOriginUrl != "about:internet";
let detectedDownloadsSummary =
    detectedDownloads
    // Get a few examples for each detected Host:
    // up to 4 filenames, up to 4 threat names, one full URL)
    | summarize DetectedUrl=any(FileOriginUrl),
                DetectedFiles=makeset(FileName, 4),
                ThreatNames=makeset(ThreatName, 4)
                by Host=tostring(parse_url(FileOriginUrl).Host);
// Query for downloads from sites from which other downloads were detected by Windows Defender Antivirus
DeviceFileEvents
| where isnotempty(FileOriginUrl)
| project FileName, FileOriginUrl, DeviceId, Timestamp,
          Host=tostring(parse_url(FileOriginUrl).Host), SHA1 
// Filter downloads from hosts serving detected files
| join kind=inner(detectedDownloadsSummary) on Host
// Filter out download file create events that were also detected.
// This is needed because sometimes both of these events will be reported, 
// and sometimes only the AntivirusDetection event - depending on timing.
| join kind=leftanti(detectedDownloads) on DeviceId, FileOriginUrl
// Summarize a single row per host - with the machines count 
// and an example event for a missed download (select the last event)
| summarize MachineCount=dcount(DeviceId), arg_max(Timestamp, *) by Host
// Filter out common hosts, as they probably ones that also serve benign files
| where MachineCount < 20
| project Host, MachineCount, DeviceId, FileName, DetectedFiles, 
          FileOriginUrl, DetectedUrl, ThreatNames, Timestamp, SHA1
| order by MachineCount desc 

```

## Email link + download + SmartScreen warning

Look for links opened from outlook.exe, followed by a browser download and then a SmartScreen app warning that was ignored by the user.
Read more about these events and this hunting approach in this post: https://techcommunity.microsoft.com/t5/forums/editpage/board-id/WDATPActor/message-id/34.
Data availability: SmartScreen events are available only on Windows 10 version 1703 and onwards.
Tags: #EmailLink, #BrowserDownload, #SmartScreen.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | b29c75ca-a110-4c58-8d0b-6afac6d61078 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Email%20link%20+%20download%20+%20SmartScreen%20warning.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let smartscreenAppWarnings =
// Query for SmartScreen warnings of unknown executed applications
    DeviceEvents
    | where ActionType == "SmartScreenAppWarning"
    | project WarnTime=Timestamp, DeviceName, WarnedFileName=FileName, WarnedSHA1=SHA1, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string))
    // Select only warnings that the user has decided to ignore and has executed the app.
    | join kind=leftsemi (
            DeviceEvents
            | where ActionType == "SmartScreenUserOverride"
            | project DeviceName, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string)))
         on DeviceName, ActivityId
	| project-away ActivityId;
// Query for links opened from outlook, that are close in time to a SmartScreen warning
let emailLinksNearSmartScreenWarnings =
    DeviceEvents
    | where ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "outlook.exe"
    | extend WasOutlookSafeLink=(tostring(parse_url(RemoteUrl).Host) endswith "safelinks.protection.outlook.com")
    | project DeviceName, MailLinkTime=Timestamp,
        MailLink=iff(WasOutlookSafeLink, url_decode(tostring(parse_url(RemoteUrl)["Query Parameters"]["url"])), RemoteUrl)
    | join kind=inner smartscreenAppWarnings on DeviceName | where (WarnTime-MailLinkTime) between (0min..4min);
// Add the browser download event to tie in all the dots
DeviceFileEvents
| where isnotempty(FileOriginUrl) and InitiatingProcessFileName in~ ("chrome.exe", "browser_broker.exe")
| project FileName, FileOriginUrl, FileOriginReferrerUrl, DeviceName, Timestamp, SHA1
| join kind=inner emailLinksNearSmartScreenWarnings on DeviceName
| where (Timestamp-MailLinkTime) between (0min..3min) and (WarnTime-Timestamp) between (0min..1min)
| project FileName, MailLink, FileOriginUrl, FileOriginReferrerUrl, WarnedFileName, DeviceName, SHA1, WarnedSHA1, Timestamp
| distinct *

```

## Email link + download + SmartScreen warning

Look for links opened from outlook.exe, followed by a browser download and then a SmartScreen app warning that was ignored by the user.
Read more about these events and this hunting approach in this post: https://techcommunity.microsoft.com/t5/forums/editpage/board-id/WDATPActor/message-id/34.
Data availability: SmartScreen events are available only on Windows 10 version 1703 and onwards.
Tags: #EmailLink, #BrowserDownload, #SmartScreen.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | b29c75ca-a110-4c58-8d0b-6afac6d61078 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Email%20link%20+%20download%20+%20SmartScreen%20warning.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let smartscreenAppWarnings =
// Query for SmartScreen warnings of unknown executed applications
    DeviceEvents
    | where ActionType == "SmartScreenAppWarning"
    | project WarnTime=Timestamp, DeviceName, WarnedFileName=FileName, WarnedSHA1=SHA1, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string))
    // Select only warnings that the user has decided to ignore and has executed the app.
    | join kind=leftsemi (
            DeviceEvents
            | where ActionType == "SmartScreenUserOverride"
            | project DeviceName, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string)))
         on DeviceName, ActivityId
	| project-away ActivityId;
// Query for links opened from outlook, that are close in time to a SmartScreen warning
let emailLinksNearSmartScreenWarnings =
    DeviceEvents
    | where ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "outlook.exe"
    | extend WasOutlookSafeLink=(tostring(parse_url(RemoteUrl).Host) endswith "safelinks.protection.outlook.com")
    | project DeviceName, MailLinkTime=Timestamp,
        MailLink=iff(WasOutlookSafeLink, url_decode(tostring(parse_url(RemoteUrl)["Query Parameters"]["url"])), RemoteUrl)
    | join kind=inner smartscreenAppWarnings on DeviceName | where (WarnTime-MailLinkTime) between (0min..4min);
// Add the browser download event to tie in all the dots
DeviceFileEvents
| where isnotempty(FileOriginUrl) and InitiatingProcessFileName in~ ("chrome.exe", "browser_broker.exe")
| project FileName, FileOriginUrl, FileOriginReferrerUrl, DeviceName, Timestamp, SHA1
| join kind=inner emailLinksNearSmartScreenWarnings on DeviceName
| where (Timestamp-MailLinkTime) between (0min..3min) and (WarnTime-Timestamp) between (0min..1min)
| project FileName, MailLink, FileOriginUrl, FileOriginReferrerUrl, WarnedFileName, DeviceName, SHA1, WarnedSHA1, Timestamp
| distinct *

```

## Email link + download + SmartScreen warning

Look for links opened from outlook.exe, followed by a browser download and then a SmartScreen app warning that was ignored by the user.
Read more about these events and this hunting approach in this post: https://techcommunity.microsoft.com/t5/forums/editpage/board-id/WDATPActor/message-id/34.
Data availability: SmartScreen events are available only on Windows 10 version 1703 and onwards.
Tags: #EmailLink, #BrowserDownload, #SmartScreen.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | b29c75ca-a110-4c58-8d0b-6afac6d61078 |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Email%20link%20+%20download%20+%20SmartScreen%20warning.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let smartscreenAppWarnings =
// Query for SmartScreen warnings of unknown executed applications
    DeviceEvents
    | where ActionType == "SmartScreenAppWarning"
    | project WarnTime=Timestamp, DeviceName, WarnedFileName=FileName, WarnedSHA1=SHA1, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string))
    // Select only warnings that the user has decided to ignore and has executed the app.
    | join kind=leftsemi (
            DeviceEvents
            | where ActionType == "SmartScreenUserOverride"
            | project DeviceName, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string)))
         on DeviceName, ActivityId
	| project-away ActivityId;
// Query for links opened from outlook, that are close in time to a SmartScreen warning
let emailLinksNearSmartScreenWarnings =
    DeviceEvents
    | where ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "outlook.exe"
    | extend WasOutlookSafeLink=(tostring(parse_url(RemoteUrl).Host) endswith "safelinks.protection.outlook.com")
    | project DeviceName, MailLinkTime=Timestamp,
        MailLink=iff(WasOutlookSafeLink, url_decode(tostring(parse_url(RemoteUrl)["Query Parameters"]["url"])), RemoteUrl)
    | join kind=inner smartscreenAppWarnings on DeviceName | where (WarnTime-MailLinkTime) between (0min..4min);
// Add the browser download event to tie in all the dots
DeviceFileEvents
| where isnotempty(FileOriginUrl) and InitiatingProcessFileName in~ ("chrome.exe", "browser_broker.exe")
| project FileName, FileOriginUrl, FileOriginReferrerUrl, DeviceName, Timestamp, SHA1
| join kind=inner emailLinksNearSmartScreenWarnings on DeviceName
| where (Timestamp-MailLinkTime) between (0min..3min) and (WarnTime-Timestamp) between (0min..1min)
| project FileName, MailLink, FileOriginUrl, FileOriginReferrerUrl, WarnedFileName, DeviceName, SHA1, WarnedSHA1, Timestamp
| distinct *

```

## Email link + download + SmartScreen warning

Look for links opened from outlook.exe, followed by a browser download and then a SmartScreen app warning that was ignored by the user.
Read more about these events and this hunting approach in this post: https://techcommunity.microsoft.com/t5/forums/editpage/board-id/WDATPActor/message-id/34.
Data availability: SmartScreen events are available only on Windows 10 version 1703 and onwards.
Tags: #EmailLink, #BrowserDownload, #SmartScreen.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | b29c75ca-a110-4c58-8d0b-6afac6d61078 |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Email%20link%20+%20download%20+%20SmartScreen%20warning.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let smartscreenAppWarnings =
// Query for SmartScreen warnings of unknown executed applications
    DeviceEvents
    | where ActionType == "SmartScreenAppWarning"
    | project WarnTime=Timestamp, DeviceName, WarnedFileName=FileName, WarnedSHA1=SHA1, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string))
    // Select only warnings that the user has decided to ignore and has executed the app.
    | join kind=leftsemi (
            DeviceEvents
            | where ActionType == "SmartScreenUserOverride"
            | project DeviceName, ActivityId=extractjson("$.ActivityId", AdditionalFields, typeof(string)))
         on DeviceName, ActivityId
	| project-away ActivityId;
// Query for links opened from outlook, that are close in time to a SmartScreen warning
let emailLinksNearSmartScreenWarnings =
    DeviceEvents
    | where ActionType == "BrowserLaunchedToOpenUrl" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ "outlook.exe"
    | extend WasOutlookSafeLink=(tostring(parse_url(RemoteUrl).Host) endswith "safelinks.protection.outlook.com")
    | project DeviceName, MailLinkTime=Timestamp,
        MailLink=iff(WasOutlookSafeLink, url_decode(tostring(parse_url(RemoteUrl)["Query Parameters"]["url"])), RemoteUrl)
    | join kind=inner smartscreenAppWarnings on DeviceName | where (WarnTime-MailLinkTime) between (0min..4min);
// Add the browser download event to tie in all the dots
DeviceFileEvents
| where isnotempty(FileOriginUrl) and InitiatingProcessFileName in~ ("chrome.exe", "browser_broker.exe")
| project FileName, FileOriginUrl, FileOriginReferrerUrl, DeviceName, Timestamp, SHA1
| join kind=inner emailLinksNearSmartScreenWarnings on DeviceName
| where (Timestamp-MailLinkTime) between (0min..3min) and (WarnTime-Timestamp) between (0min..1min)
| project FileName, MailLink, FileOriginUrl, FileOriginReferrerUrl, WarnedFileName, DeviceName, SHA1, WarnedSHA1, Timestamp
| distinct *

```

## Gootkit-malware

This query was originally published on Twitter, by @MsftSecIntel.
Gootkit is malware that started life as a banking trojan, and has since extended its capabilities to allow for a variety of malicious activities.
The query helps find events related to Gootkit downloads and command-and-control behavior.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Command and control|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c8796d76-9a84-4cc8-91b5-d01f882869d4 |
|DataTypes | AlertInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Gootkit-malware.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
AlertInfo | where Title =~ "Suspected delivery of Gootkit malware"
// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see
// only file create events where the malware may be present but has not yet been executed.
////
// Get alert evidence
| join AlertEvidence on $left.AlertId == $right.AlertId
// Look for C2
| join DeviceNetworkEvents  on $left.DeviceId == $right.DeviceId
| where InitiatingProcessFileName =~ "wscript.exe" and InitiatingProcessCommandLine has ".zip" and InitiatingProcessCommandLine has ".js"
| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, 
InitiatingProcessFileName, AlertId, Title, AccountName

```

## Gootkit-malware

This query was originally published on Twitter, by @MsftSecIntel.
Gootkit is malware that started life as a banking trojan, and has since extended its capabilities to allow for a variety of malicious activities.
The query helps find events related to Gootkit downloads and command-and-control behavior.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Command and control|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c8796d76-9a84-4cc8-91b5-d01f882869d4 |
|DataTypes | AlertInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Gootkit-malware.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
AlertInfo | where Title =~ "Suspected delivery of Gootkit malware"
// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see
// only file create events where the malware may be present but has not yet been executed.
////
// Get alert evidence
| join AlertEvidence on $left.AlertId == $right.AlertId
// Look for C2
| join DeviceNetworkEvents  on $left.DeviceId == $right.DeviceId
| where InitiatingProcessFileName =~ "wscript.exe" and InitiatingProcessCommandLine has ".zip" and InitiatingProcessCommandLine has ".js"
| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, 
InitiatingProcessFileName, AlertId, Title, AccountName

```

## Gootkit-malware

This query was originally published on Twitter, by @MsftSecIntel.
Gootkit is malware that started life as a banking trojan, and has since extended its capabilities to allow for a variety of malicious activities.
The query helps find events related to Gootkit downloads and command-and-control behavior.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Command and control|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c8796d76-9a84-4cc8-91b5-d01f882869d4 |
|DataTypes | AlertEvidence |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Gootkit-malware.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
AlertInfo | where Title =~ "Suspected delivery of Gootkit malware"
// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see
// only file create events where the malware may be present but has not yet been executed.
////
// Get alert evidence
| join AlertEvidence on $left.AlertId == $right.AlertId
// Look for C2
| join DeviceNetworkEvents  on $left.DeviceId == $right.DeviceId
| where InitiatingProcessFileName =~ "wscript.exe" and InitiatingProcessCommandLine has ".zip" and InitiatingProcessCommandLine has ".js"
| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, 
InitiatingProcessFileName, AlertId, Title, AccountName

```

## Gootkit-malware

This query was originally published on Twitter, by @MsftSecIntel.
Gootkit is malware that started life as a banking trojan, and has since extended its capabilities to allow for a variety of malicious activities.
The query helps find events related to Gootkit downloads and command-and-control behavior.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Command and control|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c8796d76-9a84-4cc8-91b5-d01f882869d4 |
|DataTypes | AlertEvidence |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Gootkit-malware.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
AlertInfo | where Title =~ "Suspected delivery of Gootkit malware"
// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see
// only file create events where the malware may be present but has not yet been executed.
////
// Get alert evidence
| join AlertEvidence on $left.AlertId == $right.AlertId
// Look for C2
| join DeviceNetworkEvents  on $left.DeviceId == $right.DeviceId
| where InitiatingProcessFileName =~ "wscript.exe" and InitiatingProcessCommandLine has ".zip" and InitiatingProcessCommandLine has ".js"
| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, 
InitiatingProcessFileName, AlertId, Title, AccountName

```

## Gootkit-malware

This query was originally published on Twitter, by @MsftSecIntel.
Gootkit is malware that started life as a banking trojan, and has since extended its capabilities to allow for a variety of malicious activities.
The query helps find events related to Gootkit downloads and command-and-control behavior.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Command and control|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c8796d76-9a84-4cc8-91b5-d01f882869d4 |
|DataTypes | DeviceNetworkEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Gootkit-malware.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
AlertInfo | where Title =~ "Suspected delivery of Gootkit malware"
// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see
// only file create events where the malware may be present but has not yet been executed.
////
// Get alert evidence
| join AlertEvidence on $left.AlertId == $right.AlertId
// Look for C2
| join DeviceNetworkEvents  on $left.DeviceId == $right.DeviceId
| where InitiatingProcessFileName =~ "wscript.exe" and InitiatingProcessCommandLine has ".zip" and InitiatingProcessCommandLine has ".js"
| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, 
InitiatingProcessFileName, AlertId, Title, AccountName

```

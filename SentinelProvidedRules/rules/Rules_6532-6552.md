# Rules: 6532-6552

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | AlertInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | AlertInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | AlertEvidence |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | AlertEvidence |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | EmailEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | EmailEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | IdentityInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | IdentityInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## SuspiciousUrlClicked

This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.
This event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 959f8d6a-53b8-488f-a628-999b3410702e |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
// Some URL are wrapped with a safelink
// Let's get the the unwrapped url and clicks 
AlertInfo
| where ServiceSource == "Office 365 ATP"
| join (
        AlertEvidence
        | where EntityType =="Url"
        | project AlertId, RemoteUrl 
    )
    on AlertId
| join (
        AlertEvidence
        | where EntityType =="MailMessage"
        | project AlertId, NetworkMessageId 
    )
    on AlertId
// Get the unique NetworkMessageId for the email containing the Url
| distinct RemoteUrl, NetworkMessageId
| join EmailEvents on NetworkMessageId
// Get the email RecipientEmailAddress and ObjectId from the email 
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId
| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId 
// get the UserSid of the Recipient
| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid 
// Get the Url click event on the recipient device.
| join kind = inner  
    (DeviceEvents 
    | where ActionType == "BrowserLaunchedToOpenUrl"| where isnotempty(RemoteUrl) 
    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, 
                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName
    ) 
   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid
| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, 
    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName 
| sort by UrlDeviceClickTime desc 

```

## PhishingEmailUrlRedirector

This query was originally published on Twitter, by @MsftSecIntel.
The query helps detect emails associated with a campaign that has used open redirector URLs. The campaign's URLs begin with the distinct pattern, hxxps://t. Attackers use URL redirection to manipulate users into visiting a malicious website or to evade detection.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c73911ab-bcc0-4add-9963-597d2fb74488 |
|DataTypes | EmailUrlInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/PhishingEmailUrlRedirector.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
EmailUrlInfo
| where Url matches regex @"s?\:\/\/(?:www\.)?t\.(?:[\w\-\.]+\/+)+(?:r|redirect)\/?\?"

```

## PhishingEmailUrlRedirector

This query was originally published on Twitter, by @MsftSecIntel.
The query helps detect emails associated with a campaign that has used open redirector URLs. The campaign's URLs begin with the distinct pattern, hxxps://t. Attackers use URL redirection to manipulate users into visiting a malicious website or to evade detection.
Reference - https://twitter.com/MsftSecIntel

|Name | Value |
| --- | --- |
|Tactic | Initial access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | c73911ab-bcc0-4add-9963-597d2fb74488 |
|DataTypes | EmailUrlInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/PhishingEmailUrlRedirector.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
EmailUrlInfo
| where Url matches regex @"s?\:\/\/(?:www\.)?t\.(?:[\w\-\.]+\/+)+(?:r|redirect)\/?\?"

```

## EmojiHunt

Did you know you can use Emojis in Windows?.
Read more here: https://davidzych.com/abusing-emoji-in-windows.
Check-out who in your organization has renamed his or her computer to a Pizza or to a smiling poop.
You might be amused by the results, or perhaps angry if one of your systems or scripts was broken by this...
Note: this query will also return some machines with non-English charcters that are not Emojis.
Credit for this query goes to miflower - thanks for bringing joy to our lives! :).

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 3e246f82-6a80-4cd3-8d4c-8afa2b7451d2 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Fun/EmojiHunt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
DeviceProcessEvents
| distinct DeviceName
| extend fakeescape=replace("%5f", "_", replace("%2d", "-", url_encode(DeviceName)))
| where fakeescape != DeviceName

```

## EmojiHunt

Did you know you can use Emojis in Windows?.
Read more here: https://davidzych.com/abusing-emoji-in-windows.
Check-out who in your organization has renamed his or her computer to a Pizza or to a smiling poop.
You might be amused by the results, or perhaps angry if one of your systems or scripts was broken by this...
Note: this query will also return some machines with non-English charcters that are not Emojis.
Credit for this query goes to miflower - thanks for bringing joy to our lives! :).

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 3e246f82-6a80-4cd3-8d4c-8afa2b7451d2 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Fun/EmojiHunt.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
DeviceProcessEvents
| distinct DeviceName
| extend fakeescape=replace("%5f", "_", replace("%2d", "-", url_encode(DeviceName)))
| where fakeescape != DeviceName

```

## Make FolderPath Vogon Poetry

This is a completely stupid and pointless query that makes Vogon poetry out
of a random FolderPath from the table you pass it.  You can change
DeviceProcessEvents for any table as long as it has a column named DeviceName
and a column called FolderPath.  Feel free to check in more verses :)
Don't know what Vogon poetry is?  You have a research assignment: http://tinyurl.com/y8ueqchl

|Name | Value |
| --- | --- |
|Tactic | Creates Poetry|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 3dbe65c4-c2ba-4139-9d7e-bf551d50d600 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Fun/Make%20FolderPath%20Vogon%20Poetry.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let MakeFolderPathVogonPoetry = (SourceData:(DeviceName:string, FolderPath:string)) {
    let Verses = pack_array(
        'My life was spent with PATH', 
        'Looking upon a barren PATH',
        'Whilst in the distance I saw a PATH',
        'Gazing at the PATH',
        'It was quite the dreary PATH',
        'As I sat alone in the PATH',
        'It was such a beautiful PATH',
        'Though I could choose only one PATH',
        'While I longed for my PATH',
        'I would never find PATH again',
        'I hunt in PATH',
        'The PATH my guide',
        'The memory of PATH sings in my blood',
        'I seize the PATH',
        'I carry it to my PATH',
        'And I lay my PATH at your feet'
    );    
    let PhraseCount = toscalar(array_length(Verses));
    let CleanedSourceData = (
        SourceData
        | take 10000
        | where isnotempty( FolderPath) and (FolderPath startswith "/" or FolderPath startswith "c:\\")
        | project DeviceName, FolderPath
    );
    let RandRow = rand(toscalar(CleanedSourceData | count));
    CleanedSourceData
    | serialize 
    | where row_number() == RandRow
    | extend Path = iff(FolderPath startswith "/", split(FolderPath, '/'), split(FolderPath, '\\'))
    | where array_length( Path ) > 2
    | mvexpand Path to typeof(string)
    | where isnotempty(Path)
    | extend Rand = toint(rand(PhraseCount))
    | extend VerseTemplate = tostring(Verses[Rand])
    | extend Verse = strcat(substring(VerseTemplate,0,indexof(VerseTemplate, 'PATH')), Path, substring(VerseTemplate, (indexof(VerseTemplate, 'PATH') + 4), (strlen(VerseTemplate) -  indexof(VerseTemplate, 'PATH') + 4))) 
    | serialize 
    | project DeviceName, FolderPath, Verse
};
DeviceProcessEvents
| invoke MakeFolderPathVogonPoetry()

```

## Make FolderPath Vogon Poetry

This is a completely stupid and pointless query that makes Vogon poetry out
of a random FolderPath from the table you pass it.  You can change
DeviceProcessEvents for any table as long as it has a column named DeviceName
and a column called FolderPath.  Feel free to check in more verses :)
Don't know what Vogon poetry is?  You have a research assignment: http://tinyurl.com/y8ueqchl

|Name | Value |
| --- | --- |
|Tactic | Creates Poetry|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 3dbe65c4-c2ba-4139-9d7e-bf551d50d600 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Fun/Make%20FolderPath%20Vogon%20Poetry.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let MakeFolderPathVogonPoetry = (SourceData:(DeviceName:string, FolderPath:string)) {
    let Verses = pack_array(
        'My life was spent with PATH', 
        'Looking upon a barren PATH',
        'Whilst in the distance I saw a PATH',
        'Gazing at the PATH',
        'It was quite the dreary PATH',
        'As I sat alone in the PATH',
        'It was such a beautiful PATH',
        'Though I could choose only one PATH',
        'While I longed for my PATH',
        'I would never find PATH again',
        'I hunt in PATH',
        'The PATH my guide',
        'The memory of PATH sings in my blood',
        'I seize the PATH',
        'I carry it to my PATH',
        'And I lay my PATH at your feet'
    );    
    let PhraseCount = toscalar(array_length(Verses));
    let CleanedSourceData = (
        SourceData
        | take 10000
        | where isnotempty( FolderPath) and (FolderPath startswith "/" or FolderPath startswith "c:\\")
        | project DeviceName, FolderPath
    );
    let RandRow = rand(toscalar(CleanedSourceData | count));
    CleanedSourceData
    | serialize 
    | where row_number() == RandRow
    | extend Path = iff(FolderPath startswith "/", split(FolderPath, '/'), split(FolderPath, '\\'))
    | where array_length( Path ) > 2
    | mvexpand Path to typeof(string)
    | where isnotempty(Path)
    | extend Rand = toint(rand(PhraseCount))
    | extend VerseTemplate = tostring(Verses[Rand])
    | extend Verse = strcat(substring(VerseTemplate,0,indexof(VerseTemplate, 'PATH')), Path, substring(VerseTemplate, (indexof(VerseTemplate, 'PATH') + 4), (strlen(VerseTemplate) -  indexof(VerseTemplate, 'PATH') + 4))) 
    | serialize 
    | project DeviceName, FolderPath, Verse
};
DeviceProcessEvents
| invoke MakeFolderPathVogonPoetry()

```

## wdigest-caching

This query was originally published in the threat analytics report, WDigest credential harvesting.
WDigest is a legacy authentication protocol dating from Windows XP. While still used on some corporate networks, this protocol can be manipulated by attackers to dump system credentials.
The Microsoft Security Response Center published an overview of KB2871997, which addresses WDigest use on older platforms. More recent versions of Windows can be protected with a holistic security approach that follows the principle of least privilege.
The following query returns any attempts to turn WDigest credential caching on through the registry.
References:
https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc778868(v=ws.10)?redirectedfrom=MSDN
https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/
https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997
https://docs.microsoft.com/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models

|Name | Value |
| --- | --- |
|Tactic | Credential Access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 05a01ec8-ecab-4f9a-9aae-8d8cc061fe05 |
|DataTypes | DeviceRegistryEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/wdigest-caching.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceRegistryEvents, DeviceProcessEvents
// Find attempts to turn on WDigest credential caching
| where RegistryKey contains "wdigest" and RegistryValueName == "UseLogonCredential" and 
RegistryValueData == "1" or 
// Find processes created with commandlines that attempt to turn on WDigest caching
ProcessCommandLine has "WDigest" and ProcessCommandLine has "UseLogonCredential" and 
ProcessCommandLine has "dword" and ProcessCommandLine has "1"
| project Timestamp, DeviceName, PreviousRegistryValueData,  
RegistryKey, RegistryValueName, RegistryValueData, FileName, ProcessCommandLine, 
InitiatingProcessAccountName, InitiatingProcessFileName, 
InitiatingProcessCommandLine, InitiatingProcessParentFileName

```

## wdigest-caching

This query was originally published in the threat analytics report, WDigest credential harvesting.
WDigest is a legacy authentication protocol dating from Windows XP. While still used on some corporate networks, this protocol can be manipulated by attackers to dump system credentials.
The Microsoft Security Response Center published an overview of KB2871997, which addresses WDigest use on older platforms. More recent versions of Windows can be protected with a holistic security approach that follows the principle of least privilege.
The following query returns any attempts to turn WDigest credential caching on through the registry.
References:
https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc778868(v=ws.10)?redirectedfrom=MSDN
https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/
https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997
https://docs.microsoft.com/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models

|Name | Value |
| --- | --- |
|Tactic | Credential Access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 05a01ec8-ecab-4f9a-9aae-8d8cc061fe05 |
|DataTypes | DeviceRegistryEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/wdigest-caching.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceRegistryEvents, DeviceProcessEvents
// Find attempts to turn on WDigest credential caching
| where RegistryKey contains "wdigest" and RegistryValueName == "UseLogonCredential" and 
RegistryValueData == "1" or 
// Find processes created with commandlines that attempt to turn on WDigest caching
ProcessCommandLine has "WDigest" and ProcessCommandLine has "UseLogonCredential" and 
ProcessCommandLine has "dword" and ProcessCommandLine has "1"
| project Timestamp, DeviceName, PreviousRegistryValueData,  
RegistryKey, RegistryValueName, RegistryValueData, FileName, ProcessCommandLine, 
InitiatingProcessAccountName, InitiatingProcessFileName, 
InitiatingProcessCommandLine, InitiatingProcessParentFileName

```

## wdigest-caching

This query was originally published in the threat analytics report, WDigest credential harvesting.
WDigest is a legacy authentication protocol dating from Windows XP. While still used on some corporate networks, this protocol can be manipulated by attackers to dump system credentials.
The Microsoft Security Response Center published an overview of KB2871997, which addresses WDigest use on older platforms. More recent versions of Windows can be protected with a holistic security approach that follows the principle of least privilege.
The following query returns any attempts to turn WDigest credential caching on through the registry.
References:
https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc778868(v=ws.10)?redirectedfrom=MSDN
https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/
https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997
https://docs.microsoft.com/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models

|Name | Value |
| --- | --- |
|Tactic | Credential Access|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 05a01ec8-ecab-4f9a-9aae-8d8cc061fe05 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/wdigest-caching.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceRegistryEvents, DeviceProcessEvents
// Find attempts to turn on WDigest credential caching
| where RegistryKey contains "wdigest" and RegistryValueName == "UseLogonCredential" and 
RegistryValueData == "1" or 
// Find processes created with commandlines that attempt to turn on WDigest caching
ProcessCommandLine has "WDigest" and ProcessCommandLine has "UseLogonCredential" and 
ProcessCommandLine has "dword" and ProcessCommandLine has "1"
| project Timestamp, DeviceName, PreviousRegistryValueData,  
RegistryKey, RegistryValueName, RegistryValueData, FileName, ProcessCommandLine, 
InitiatingProcessAccountName, InitiatingProcessFileName, 
InitiatingProcessCommandLine, InitiatingProcessParentFileName

```

## wdigest-caching

This query was originally published in the threat analytics report, WDigest credential harvesting.
WDigest is a legacy authentication protocol dating from Windows XP. While still used on some corporate networks, this protocol can be manipulated by attackers to dump system credentials.
The Microsoft Security Response Center published an overview of KB2871997, which addresses WDigest use on older platforms. More recent versions of Windows can be protected with a holistic security approach that follows the principle of least privilege.
The following query returns any attempts to turn WDigest credential caching on through the registry.
References:
https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc778868(v=ws.10)?redirectedfrom=MSDN
https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/
https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997
https://docs.microsoft.com/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models

|Name | Value |
| --- | --- |
|Tactic | Credential Access|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 05a01ec8-ecab-4f9a-9aae-8d8cc061fe05 |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/wdigest-caching.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceRegistryEvents, DeviceProcessEvents
// Find attempts to turn on WDigest credential caching
| where RegistryKey contains "wdigest" and RegistryValueName == "UseLogonCredential" and 
RegistryValueData == "1" or 
// Find processes created with commandlines that attempt to turn on WDigest caching
ProcessCommandLine has "WDigest" and ProcessCommandLine has "UseLogonCredential" and 
ProcessCommandLine has "dword" and ProcessCommandLine has "1"
| project Timestamp, DeviceName, PreviousRegistryValueData,  
RegistryKey, RegistryValueName, RegistryValueData, FileName, ProcessCommandLine, 
InitiatingProcessAccountName, InitiatingProcessFileName, 
InitiatingProcessCommandLine, InitiatingProcessParentFileName

```

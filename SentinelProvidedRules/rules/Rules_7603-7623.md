# Rules: 7603-7623

## AddedCredentialFromContryXAndSigninFromCountryY

Added credential from country X and Signed-In from country Y in a pecific time window:
This query tries to find all applications that credentials were added to them from country X while the application's identity Signed-In from country Y in a specific time window.

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 9644e2ae-07a2-4086-a85a-6ee2bca45f4e |
|DataTypes | AADSpnSignInEventsBeta |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/AddedCredentialFromContryXAndSigninFromCountryY.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let timewindow = 1d;
let addedApps = (
CloudAppEvents
| where Application == "Office 365"
| where ActionType in ("Add service principal credentials.", "Update application - Certificates and secrets management ")
| project AddedTimestamp = Timestamp , AppName = tostring(RawEventData.Target[3].ID), CountryCode );
AADSpnSignInEventsBeta
| join addedApps on $left.ServicePrincipalName == $right.AppName
| where CountryCode != Country and AddedTimestamp + timewindow > Timestamp

```

## localAdminAccountLogon

This query looks for local admin account used to logon into the computer.
This can help to detect malicious insiders that were able to add a local account to the local admin group offline.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 2211b57b-7d13-435d-89a9-40f333249605 |
|DataTypes | DeviceLogonEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/localAdminAccountLogon.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
DeviceLogonEvents
| where IsLocalAdmin == 1
 and AccountDomain == DeviceName

```

## localAdminAccountLogon

This query looks for local admin account used to logon into the computer.
This can help to detect malicious insiders that were able to add a local account to the local admin group offline.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 2211b57b-7d13-435d-89a9-40f333249605 |
|DataTypes | DeviceLogonEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/localAdminAccountLogon.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
DeviceLogonEvents
| where IsLocalAdmin == 1
 and AccountDomain == DeviceName

```

## Accessibility Features

This query looks for persistence or priviledge escalation done using Windows Accessibility features.
It covers some of the techniques that could be used to utilize these features for malicious purposes,.
Including attaching a debugger using a registry config or overwriting these files.
Note: some developers might use such hacks for all sort of troubleshooting and testing purposes,.
But this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.
Read more here: https://attack.mitre.org/wiki/Technique/T1015.
Tags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a5649d8b-e54b-4e2b-925a-106bf838d69c |
|DataTypes | DeviceRegistryEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTime = ago(7d);
let accessibilityProcessNames = dynamic(["utilman.exe","osk.exe","magnify.exe","narrator.exe","displayswitch.exe","atbroker.exe","sethc.exe", "helppane.exe"]);
// Query for debuggers attached using a Registry setting to the accessibility processes
let attachedDebugger =
    DeviceRegistryEvents
    | where Timestamp > minTime
    and RegistryKey startswith @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\"
    and RegistryValueName =~ "debugger"
	// Parse the debugged process name from the registry key
    | parse RegistryKey with @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\" FileName
    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)
    | project Technique="AttachedDebugger", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;
// Query for overwrites of the accessibility files
let fileOverwiteOfAccessibilityFiles =
    DeviceFileEvents
    | where Timestamp > minTime
        and FileName in~ (accessibilityProcessNames)
        and FolderPath contains @"Windows\System32" 
    | project Technique="OverwriteFile", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;
// Query for unexpected hashes of processes with names matching the accessibility processes.
// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.
let executedProcessIsPowershellOrCmd =
    DeviceProcessEvents 
    | project Technique="PreviousOverwriteFile", Timestamp, DeviceName, FileName, SHA1 
    | where Timestamp > minTime
    | where FileName in~ (accessibilityProcessNames)
    | join kind=leftsemi(
        DeviceProcessEvents  
        | where Timestamp > ago(14d) and (FileName =~ "cmd.exe" or FileName =~ "powershell.exe")
        | summarize MachinesCount = dcount(DeviceName) by SHA1  
        | where MachinesCount > 5
        | project SHA1
    ) on SHA1;
// Union all results together. 
// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.
attachedDebugger
| union kind=outer fileOverwiteOfAccessibilityFiles
| union kind=outer executedProcessIsPowershellOrCmd

```

## Accessibility Features

This query looks for persistence or priviledge escalation done using Windows Accessibility features.
It covers some of the techniques that could be used to utilize these features for malicious purposes,.
Including attaching a debugger using a registry config or overwriting these files.
Note: some developers might use such hacks for all sort of troubleshooting and testing purposes,.
But this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.
Read more here: https://attack.mitre.org/wiki/Technique/T1015.
Tags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a5649d8b-e54b-4e2b-925a-106bf838d69c |
|DataTypes | DeviceRegistryEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTime = ago(7d);
let accessibilityProcessNames = dynamic(["utilman.exe","osk.exe","magnify.exe","narrator.exe","displayswitch.exe","atbroker.exe","sethc.exe", "helppane.exe"]);
// Query for debuggers attached using a Registry setting to the accessibility processes
let attachedDebugger =
    DeviceRegistryEvents
    | where Timestamp > minTime
    and RegistryKey startswith @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\"
    and RegistryValueName =~ "debugger"
	// Parse the debugged process name from the registry key
    | parse RegistryKey with @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\" FileName
    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)
    | project Technique="AttachedDebugger", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;
// Query for overwrites of the accessibility files
let fileOverwiteOfAccessibilityFiles =
    DeviceFileEvents
    | where Timestamp > minTime
        and FileName in~ (accessibilityProcessNames)
        and FolderPath contains @"Windows\System32" 
    | project Technique="OverwriteFile", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;
// Query for unexpected hashes of processes with names matching the accessibility processes.
// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.
let executedProcessIsPowershellOrCmd =
    DeviceProcessEvents 
    | project Technique="PreviousOverwriteFile", Timestamp, DeviceName, FileName, SHA1 
    | where Timestamp > minTime
    | where FileName in~ (accessibilityProcessNames)
    | join kind=leftsemi(
        DeviceProcessEvents  
        | where Timestamp > ago(14d) and (FileName =~ "cmd.exe" or FileName =~ "powershell.exe")
        | summarize MachinesCount = dcount(DeviceName) by SHA1  
        | where MachinesCount > 5
        | project SHA1
    ) on SHA1;
// Union all results together. 
// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.
attachedDebugger
| union kind=outer fileOverwiteOfAccessibilityFiles
| union kind=outer executedProcessIsPowershellOrCmd

```

## Accessibility Features

This query looks for persistence or priviledge escalation done using Windows Accessibility features.
It covers some of the techniques that could be used to utilize these features for malicious purposes,.
Including attaching a debugger using a registry config or overwriting these files.
Note: some developers might use such hacks for all sort of troubleshooting and testing purposes,.
But this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.
Read more here: https://attack.mitre.org/wiki/Technique/T1015.
Tags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a5649d8b-e54b-4e2b-925a-106bf838d69c |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTime = ago(7d);
let accessibilityProcessNames = dynamic(["utilman.exe","osk.exe","magnify.exe","narrator.exe","displayswitch.exe","atbroker.exe","sethc.exe", "helppane.exe"]);
// Query for debuggers attached using a Registry setting to the accessibility processes
let attachedDebugger =
    DeviceRegistryEvents
    | where Timestamp > minTime
    and RegistryKey startswith @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\"
    and RegistryValueName =~ "debugger"
	// Parse the debugged process name from the registry key
    | parse RegistryKey with @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\" FileName
    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)
    | project Technique="AttachedDebugger", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;
// Query for overwrites of the accessibility files
let fileOverwiteOfAccessibilityFiles =
    DeviceFileEvents
    | where Timestamp > minTime
        and FileName in~ (accessibilityProcessNames)
        and FolderPath contains @"Windows\System32" 
    | project Technique="OverwriteFile", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;
// Query for unexpected hashes of processes with names matching the accessibility processes.
// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.
let executedProcessIsPowershellOrCmd =
    DeviceProcessEvents 
    | project Technique="PreviousOverwriteFile", Timestamp, DeviceName, FileName, SHA1 
    | where Timestamp > minTime
    | where FileName in~ (accessibilityProcessNames)
    | join kind=leftsemi(
        DeviceProcessEvents  
        | where Timestamp > ago(14d) and (FileName =~ "cmd.exe" or FileName =~ "powershell.exe")
        | summarize MachinesCount = dcount(DeviceName) by SHA1  
        | where MachinesCount > 5
        | project SHA1
    ) on SHA1;
// Union all results together. 
// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.
attachedDebugger
| union kind=outer fileOverwiteOfAccessibilityFiles
| union kind=outer executedProcessIsPowershellOrCmd

```

## Accessibility Features

This query looks for persistence or priviledge escalation done using Windows Accessibility features.
It covers some of the techniques that could be used to utilize these features for malicious purposes,.
Including attaching a debugger using a registry config or overwriting these files.
Note: some developers might use such hacks for all sort of troubleshooting and testing purposes,.
But this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.
Read more here: https://attack.mitre.org/wiki/Technique/T1015.
Tags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a5649d8b-e54b-4e2b-925a-106bf838d69c |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTime = ago(7d);
let accessibilityProcessNames = dynamic(["utilman.exe","osk.exe","magnify.exe","narrator.exe","displayswitch.exe","atbroker.exe","sethc.exe", "helppane.exe"]);
// Query for debuggers attached using a Registry setting to the accessibility processes
let attachedDebugger =
    DeviceRegistryEvents
    | where Timestamp > minTime
    and RegistryKey startswith @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\"
    and RegistryValueName =~ "debugger"
	// Parse the debugged process name from the registry key
    | parse RegistryKey with @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\" FileName
    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)
    | project Technique="AttachedDebugger", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;
// Query for overwrites of the accessibility files
let fileOverwiteOfAccessibilityFiles =
    DeviceFileEvents
    | where Timestamp > minTime
        and FileName in~ (accessibilityProcessNames)
        and FolderPath contains @"Windows\System32" 
    | project Technique="OverwriteFile", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;
// Query for unexpected hashes of processes with names matching the accessibility processes.
// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.
let executedProcessIsPowershellOrCmd =
    DeviceProcessEvents 
    | project Technique="PreviousOverwriteFile", Timestamp, DeviceName, FileName, SHA1 
    | where Timestamp > minTime
    | where FileName in~ (accessibilityProcessNames)
    | join kind=leftsemi(
        DeviceProcessEvents  
        | where Timestamp > ago(14d) and (FileName =~ "cmd.exe" or FileName =~ "powershell.exe")
        | summarize MachinesCount = dcount(DeviceName) by SHA1  
        | where MachinesCount > 5
        | project SHA1
    ) on SHA1;
// Union all results together. 
// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.
attachedDebugger
| union kind=outer fileOverwiteOfAccessibilityFiles
| union kind=outer executedProcessIsPowershellOrCmd

```

## Accessibility Features

This query looks for persistence or priviledge escalation done using Windows Accessibility features.
It covers some of the techniques that could be used to utilize these features for malicious purposes,.
Including attaching a debugger using a registry config or overwriting these files.
Note: some developers might use such hacks for all sort of troubleshooting and testing purposes,.
But this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.
Read more here: https://attack.mitre.org/wiki/Technique/T1015.
Tags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a5649d8b-e54b-4e2b-925a-106bf838d69c |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTime = ago(7d);
let accessibilityProcessNames = dynamic(["utilman.exe","osk.exe","magnify.exe","narrator.exe","displayswitch.exe","atbroker.exe","sethc.exe", "helppane.exe"]);
// Query for debuggers attached using a Registry setting to the accessibility processes
let attachedDebugger =
    DeviceRegistryEvents
    | where Timestamp > minTime
    and RegistryKey startswith @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\"
    and RegistryValueName =~ "debugger"
	// Parse the debugged process name from the registry key
    | parse RegistryKey with @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\" FileName
    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)
    | project Technique="AttachedDebugger", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;
// Query for overwrites of the accessibility files
let fileOverwiteOfAccessibilityFiles =
    DeviceFileEvents
    | where Timestamp > minTime
        and FileName in~ (accessibilityProcessNames)
        and FolderPath contains @"Windows\System32" 
    | project Technique="OverwriteFile", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;
// Query for unexpected hashes of processes with names matching the accessibility processes.
// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.
let executedProcessIsPowershellOrCmd =
    DeviceProcessEvents 
    | project Technique="PreviousOverwriteFile", Timestamp, DeviceName, FileName, SHA1 
    | where Timestamp > minTime
    | where FileName in~ (accessibilityProcessNames)
    | join kind=leftsemi(
        DeviceProcessEvents  
        | where Timestamp > ago(14d) and (FileName =~ "cmd.exe" or FileName =~ "powershell.exe")
        | summarize MachinesCount = dcount(DeviceName) by SHA1  
        | where MachinesCount > 5
        | project SHA1
    ) on SHA1;
// Union all results together. 
// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.
attachedDebugger
| union kind=outer fileOverwiteOfAccessibilityFiles
| union kind=outer executedProcessIsPowershellOrCmd

```

## Accessibility Features

This query looks for persistence or priviledge escalation done using Windows Accessibility features.
It covers some of the techniques that could be used to utilize these features for malicious purposes,.
Including attaching a debugger using a registry config or overwriting these files.
Note: some developers might use such hacks for all sort of troubleshooting and testing purposes,.
But this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.
Read more here: https://attack.mitre.org/wiki/Technique/T1015.
Tags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | a5649d8b-e54b-4e2b-925a-106bf838d69c |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let minTime = ago(7d);
let accessibilityProcessNames = dynamic(["utilman.exe","osk.exe","magnify.exe","narrator.exe","displayswitch.exe","atbroker.exe","sethc.exe", "helppane.exe"]);
// Query for debuggers attached using a Registry setting to the accessibility processes
let attachedDebugger =
    DeviceRegistryEvents
    | where Timestamp > minTime
    and RegistryKey startswith @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\"
    and RegistryValueName =~ "debugger"
	// Parse the debugged process name from the registry key
    | parse RegistryKey with @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\" FileName
    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)
    | project Technique="AttachedDebugger", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;
// Query for overwrites of the accessibility files
let fileOverwiteOfAccessibilityFiles =
    DeviceFileEvents
    | where Timestamp > minTime
        and FileName in~ (accessibilityProcessNames)
        and FolderPath contains @"Windows\System32" 
    | project Technique="OverwriteFile", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;
// Query for unexpected hashes of processes with names matching the accessibility processes.
// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.
let executedProcessIsPowershellOrCmd =
    DeviceProcessEvents 
    | project Technique="PreviousOverwriteFile", Timestamp, DeviceName, FileName, SHA1 
    | where Timestamp > minTime
    | where FileName in~ (accessibilityProcessNames)
    | join kind=leftsemi(
        DeviceProcessEvents  
        | where Timestamp > ago(14d) and (FileName =~ "cmd.exe" or FileName =~ "powershell.exe")
        | summarize MachinesCount = dcount(DeviceName) by SHA1  
        | where MachinesCount > 5
        | project SHA1
    ) on SHA1;
// Union all results together. 
// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.
attachedDebugger
| union kind=outer fileOverwiteOfAccessibilityFiles
| union kind=outer executedProcessIsPowershellOrCmd

```

## LocalAdminGroupChanges

Author: alex verboon @alexverboon.
Blogpost: https://www.verboon.info/2020/09/hunting-for-local-group-membership-changes.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | dd2c4f48-b732-4a75-b2c4-b44bacc66d00 |
|DataTypes | IdentityInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/LocalAdminGroupChanges.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let ADAZUsers =  IdentityInfo 
| extend DirectoryDomain = AccountDomain 
| extend DirectoryAccount = AccountName 
| distinct DirectoryDomain , DirectoryAccount , OnPremSid , CloudSid, AccountUpn, GivenName, Surname;
 // check for any new created or modified local accounts 
let NewUsers =  DeviceEvents
| where ActionType contains "UserAccountCreated"  // or ActionType contains "UserAccountModified"
| extend lUserAdded = AccountName
| extend NewUserSID = AccountSid
| extend laccountdomain = AccountDomain
| distinct NewUserSID, lUserAdded,laccountdomain;
// Check for any local group changes and enrich the data with the account name obtained from the previous query
DeviceEvents 
| where ActionType == 'UserAccountAddedToLocalGroup' 
| extend AddedAccountSID = tostring(parse_json(AdditionalFields).MemberSid)
| extend LocalGroup = AccountName
| extend LocalGroupSID = AccountSid
| extend Actor = trim(@"[^\w]+",InitiatingProcessAccountName)
// limit to local administrators group
//  | where LocalGroupSID contains "S-1-5-32-544"
| join kind= leftouter    (NewUsers)
on $left.AddedAccountSID == $right.NewUserSID
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, lUserAdded , Actor, ActionType , laccountdomain 
| join kind= leftouter        (ADAZUsers)
on $left.AddedAccountSID == $right.OnPremSid
| extend UserAdded = iff(isnotempty(lUserAdded),strcat(laccountdomain,"\\", lUserAdded), strcat(DirectoryDomain,"\\", DirectoryAccount))
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, UserAdded , Actor, ActionType  
| where DeviceName !contains Actor 
// Provide details on actors that added users
// | summarize count()  by Actor 
// | join ADAZUsers
// on $left.Actor == $right.DirectoryAccount 
// | render piechart 

```

## LocalAdminGroupChanges

Author: alex verboon @alexverboon.
Blogpost: https://www.verboon.info/2020/09/hunting-for-local-group-membership-changes.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | dd2c4f48-b732-4a75-b2c4-b44bacc66d00 |
|DataTypes | IdentityInfo |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/LocalAdminGroupChanges.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let ADAZUsers =  IdentityInfo 
| extend DirectoryDomain = AccountDomain 
| extend DirectoryAccount = AccountName 
| distinct DirectoryDomain , DirectoryAccount , OnPremSid , CloudSid, AccountUpn, GivenName, Surname;
 // check for any new created or modified local accounts 
let NewUsers =  DeviceEvents
| where ActionType contains "UserAccountCreated"  // or ActionType contains "UserAccountModified"
| extend lUserAdded = AccountName
| extend NewUserSID = AccountSid
| extend laccountdomain = AccountDomain
| distinct NewUserSID, lUserAdded,laccountdomain;
// Check for any local group changes and enrich the data with the account name obtained from the previous query
DeviceEvents 
| where ActionType == 'UserAccountAddedToLocalGroup' 
| extend AddedAccountSID = tostring(parse_json(AdditionalFields).MemberSid)
| extend LocalGroup = AccountName
| extend LocalGroupSID = AccountSid
| extend Actor = trim(@"[^\w]+",InitiatingProcessAccountName)
// limit to local administrators group
//  | where LocalGroupSID contains "S-1-5-32-544"
| join kind= leftouter    (NewUsers)
on $left.AddedAccountSID == $right.NewUserSID
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, lUserAdded , Actor, ActionType , laccountdomain 
| join kind= leftouter        (ADAZUsers)
on $left.AddedAccountSID == $right.OnPremSid
| extend UserAdded = iff(isnotempty(lUserAdded),strcat(laccountdomain,"\\", lUserAdded), strcat(DirectoryDomain,"\\", DirectoryAccount))
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, UserAdded , Actor, ActionType  
| where DeviceName !contains Actor 
// Provide details on actors that added users
// | summarize count()  by Actor 
// | join ADAZUsers
// on $left.Actor == $right.DirectoryAccount 
// | render piechart 

```

## LocalAdminGroupChanges

Author: alex verboon @alexverboon.
Blogpost: https://www.verboon.info/2020/09/hunting-for-local-group-membership-changes.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | dd2c4f48-b732-4a75-b2c4-b44bacc66d00 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/LocalAdminGroupChanges.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let ADAZUsers =  IdentityInfo 
| extend DirectoryDomain = AccountDomain 
| extend DirectoryAccount = AccountName 
| distinct DirectoryDomain , DirectoryAccount , OnPremSid , CloudSid, AccountUpn, GivenName, Surname;
 // check for any new created or modified local accounts 
let NewUsers =  DeviceEvents
| where ActionType contains "UserAccountCreated"  // or ActionType contains "UserAccountModified"
| extend lUserAdded = AccountName
| extend NewUserSID = AccountSid
| extend laccountdomain = AccountDomain
| distinct NewUserSID, lUserAdded,laccountdomain;
// Check for any local group changes and enrich the data with the account name obtained from the previous query
DeviceEvents 
| where ActionType == 'UserAccountAddedToLocalGroup' 
| extend AddedAccountSID = tostring(parse_json(AdditionalFields).MemberSid)
| extend LocalGroup = AccountName
| extend LocalGroupSID = AccountSid
| extend Actor = trim(@"[^\w]+",InitiatingProcessAccountName)
// limit to local administrators group
//  | where LocalGroupSID contains "S-1-5-32-544"
| join kind= leftouter    (NewUsers)
on $left.AddedAccountSID == $right.NewUserSID
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, lUserAdded , Actor, ActionType , laccountdomain 
| join kind= leftouter        (ADAZUsers)
on $left.AddedAccountSID == $right.OnPremSid
| extend UserAdded = iff(isnotempty(lUserAdded),strcat(laccountdomain,"\\", lUserAdded), strcat(DirectoryDomain,"\\", DirectoryAccount))
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, UserAdded , Actor, ActionType  
| where DeviceName !contains Actor 
// Provide details on actors that added users
// | summarize count()  by Actor 
// | join ADAZUsers
// on $left.Actor == $right.DirectoryAccount 
// | render piechart 

```

## LocalAdminGroupChanges

Author: alex verboon @alexverboon.
Blogpost: https://www.verboon.info/2020/09/hunting-for-local-group-membership-changes.

|Name | Value |
| --- | --- |
|Tactic | |
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | dd2c4f48-b732-4a75-b2c4-b44bacc66d00 |
|DataTypes | DeviceEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/LocalAdminGroupChanges.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
let ADAZUsers =  IdentityInfo 
| extend DirectoryDomain = AccountDomain 
| extend DirectoryAccount = AccountName 
| distinct DirectoryDomain , DirectoryAccount , OnPremSid , CloudSid, AccountUpn, GivenName, Surname;
 // check for any new created or modified local accounts 
let NewUsers =  DeviceEvents
| where ActionType contains "UserAccountCreated"  // or ActionType contains "UserAccountModified"
| extend lUserAdded = AccountName
| extend NewUserSID = AccountSid
| extend laccountdomain = AccountDomain
| distinct NewUserSID, lUserAdded,laccountdomain;
// Check for any local group changes and enrich the data with the account name obtained from the previous query
DeviceEvents 
| where ActionType == 'UserAccountAddedToLocalGroup' 
| extend AddedAccountSID = tostring(parse_json(AdditionalFields).MemberSid)
| extend LocalGroup = AccountName
| extend LocalGroupSID = AccountSid
| extend Actor = trim(@"[^\w]+",InitiatingProcessAccountName)
// limit to local administrators group
//  | where LocalGroupSID contains "S-1-5-32-544"
| join kind= leftouter    (NewUsers)
on $left.AddedAccountSID == $right.NewUserSID
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, lUserAdded , Actor, ActionType , laccountdomain 
| join kind= leftouter        (ADAZUsers)
on $left.AddedAccountSID == $right.OnPremSid
| extend UserAdded = iff(isnotempty(lUserAdded),strcat(laccountdomain,"\\", lUserAdded), strcat(DirectoryDomain,"\\", DirectoryAccount))
| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, UserAdded , Actor, ActionType  
| where DeviceName !contains Actor 
// Provide details on actors that added users
// | summarize count()  by Actor 
// | join ADAZUsers
// on $left.Actor == $right.DirectoryAccount 
// | render piechart 

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Persistence|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Malware, component|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Malware, component|
|TechniqueId | |
|Platform | Windows|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceFileEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```

## detect-prifou-pua

This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.
IronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.
The following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.

|Name | Value |
| --- | --- |
|Tactic | Malware, component|
|TechniqueId | |
|Platform | Azure|
|DetectionType | Hunting |
|ConnectorId | MicrosoftThreatProtection |
|DetectionId | 62bc4944-46dd-4c2f-ba04-72837bbfec3f |
|DataTypes | DeviceProcessEvents |
|QueryFrequency |  |
|QueryPeriod |  |
|TriggerOperator |  |
|TriggerThreshold |  |
|DetectionSeverity |  |
|DetectionUrl | https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml |
|IngestedDate | 2022-08-07 |

### KQL
```kql
union DeviceFileEvents, DeviceProcessEvents 
| where Timestamp > ago(7d)
// Prifou launched by ironSource bundler
| where ProcessCommandLine has "/mhp " and ProcessCommandLine has "/mnt " 
and ProcessCommandLine has "/mds "
// InstallCore launch commands
or (ProcessCommandLine has "/mnl" and ProcessCommandLine has "rsf")
// Chromium installation
or ProcessCommandLine has "bundlename=chromium"
or FileName == "prefjsonfn.txt"
| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,
InitiatingProcessCommandLine, InitiatingProcessSHA1

```
